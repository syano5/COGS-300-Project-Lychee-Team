#define enA 9  // Enable pin for Motor A (right motor), PWM compatible
#define in1 8  // Direction control pin 1 for Motor A
#define in2 7  // Direction control pin 2 for Motor A 
#define enB 6  // Enable pin for Motor B (left motor), PWM compatible
#define in3 5  // Direction control pin 1 for Motor B
#define in4 4  // Direction control pin 2 for Motor B

// Front ultrasonic sensor (for obstacle/corner detection)
#define TRIG_PIN_FRONT 10
#define ECHO_PIN_FRONT 11

// Right side ultrasonic sensor (for wall following)
#define TRIG_PIN_SIDE 12
#define ECHO_PIN_SIDE 13

const int D_1 = 2, D_2 = 3;

// P-controller parameters for Follow Me mode
const float SET_POINT_FOLLOW = 25.0;
const float Kp_FOLLOW = 8.0;

// Wall following parameters
const float SET_POINT_WALL = 15.0;    // Target distance from wall
const float Kp_WALL = 5.0;            // Proportional gain
const int WALL_FORWARD_SPEED = 70;    // Base forward speed
const int MOTOR_TRIM = 10;            // Adjust if robot drifts

// Corner detection thresholds
const float INSIDE_CORNER_THRESHOLD = 15.0;   // Front obstacle closer than this = inside corner
const float OUTSIDE_CORNER_THRESHOLD = 50.0;  // Side wall farther than this = outside corner
const float LOST_WALL_THRESHOLD = 100.0;      // Side wall farther than this = completely lost wall

const int MAX_SPEED = 150;
const int MIN_SPEED = 50;

// Operating modes
enum Mode {
  MANUAL,
  FOLLOW_ME,
  WALL_FOLLOW,
  WALL_FOLLOW_CORNERS
};

Mode currentMode = MANUAL;

// Corner handling state
enum CornerState {
  FOLLOWING,
  INSIDE_CORNER_PAUSE_BEFORE,
  INSIDE_CORNER_TURN,
  INSIDE_CORNER_PAUSE_AFTER,
  OUTSIDE_CORNER_PAUSE_BEFORE,
  OUTSIDE_CORNER_TURN,
  OUTSIDE_CORNER_DRIVE_FORWARD,
  OUTSIDE_CORNER_PAUSE_AFTER
};

CornerState cornerState = FOLLOWING;
unsigned long cornerStartTime = 0;
unsigned long lastCornerTime = 0;
const int PAUSE_DURATION = 500;        // Reduced to 500ms
const int TURN_DURATION = 800;         // Time for 90 degree turn
const int DRIVE_FORWARD_TIME = 1000;   // Drive forward after outside turn
const int CORNER_COOLDOWN = 2000;      // 2 second cooldown between corners

// Note:
// in1 HIGH and in2 LOW --> FORWARDS
// in1 LOW and in2 HIGH --> BACKWARDS

void setup() {
  pinMode(enA, OUTPUT);
  pinMode(in1, OUTPUT);
  pinMode(in2, OUTPUT);
  pinMode(enB, OUTPUT);
  pinMode(in3, OUTPUT);
  pinMode(in4, OUTPUT);
  
  pinMode(TRIG_PIN_FRONT, OUTPUT);
  pinMode(ECHO_PIN_FRONT, INPUT);
  pinMode(TRIG_PIN_SIDE, OUTPUT);
  pinMode(ECHO_PIN_SIDE, INPUT);
  
  pinMode(D_1, INPUT_PULLUP);
  pinMode(D_2, INPUT_PULLUP);
  
  Serial.begin(9600);
  Serial.println("Robot ready!");
  Serial.println("Commands:");
  Serial.println("  w/s/a/d/x = Manual control");
  Serial.println("  f = Follow Me mode");
  Serial.println("  g = Wall Follow mode (simple)");
  Serial.println("  c = Wall Follow WITH corner detection");
  Serial.println("  t = Test sensors");
}

// Measure distance using specified sensor
float getDistance(int trigPin, int echoPin) {
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  
  long duration = pulseIn(echoPin, HIGH, 30000);
  
  if (duration == 0) {
    return -1;
  }
  
  float distance = duration * 0.034 / 2.0;
  return distance;
}

// Low-level motor control
void controlMotor(int motorA_speed, int motorB_speed) {
  // Motor A (right motor)
  if (motorA_speed >= 0) {
    digitalWrite(in1, HIGH);
    digitalWrite(in2, LOW);
  } else {
    digitalWrite(in1, LOW);
    digitalWrite(in2, HIGH);
    motorA_speed = -motorA_speed;
  }
  analogWrite(enA, constrain(motorA_speed, 0, 255));
  
  // Motor B (left motor)
  if (motorB_speed >= 0) {
    digitalWrite(in3, HIGH);
    digitalWrite(in4, LOW);
  } else {
    digitalWrite(in3, LOW);
    digitalWrite(in4, HIGH);
    motorB_speed = -motorB_speed;
  }
  analogWrite(enB, constrain(motorB_speed, 0, 255));
}

// Follow Me mode
void followMe() {
  float distance = getDistance(TRIG_PIN_FRONT, ECHO_PIN_FRONT);
  
  if (distance < 0 || distance > 100) {
    stopRobot();
    Serial.print("No object detected (distance: ");
    Serial.print(distance);
    Serial.println(" cm)");
    return;
  }
  
  float error = distance - SET_POINT_FOLLOW;
  float output = Kp_FOLLOW * error;
  int motorSpeed = constrain((int)output, -MAX_SPEED, MAX_SPEED);
  
  if (motorSpeed > 0 && motorSpeed < MIN_SPEED) {
    motorSpeed = MIN_SPEED;
  } else if (motorSpeed < 0 && motorSpeed > -MIN_SPEED) {
    motorSpeed = -MIN_SPEED;
  }
  
  if (abs(error) < 2.0) {
    stopRobot();
    Serial.print("At target: ");
    Serial.print(distance);
    Serial.println(" cm");
  } else {
    controlMotor(motorSpeed, motorSpeed);
    
    Serial.print("Distance: ");
    Serial.print(distance);
    Serial.print(" cm, Error: ");
    Serial.print(error);
    Serial.print(" cm, Speed: ");
    Serial.println(motorSpeed);
  }
}

// Simple wall following (no corner detection)
void followWall() {
  float sideDistance = getDistance(TRIG_PIN_SIDE, ECHO_PIN_SIDE);
  
  if (sideDistance < 0 || sideDistance > 100) {
    stopRobot();
    Serial.println("Lost wall sensor");
    return;
  }
  
  float error = sideDistance - SET_POINT_WALL;
  float steeringCorrection = Kp_WALL * error;
  
  int rightMotorSpeed = WALL_FORWARD_SPEED - MOTOR_TRIM;
  int leftMotorSpeed = WALL_FORWARD_SPEED + MOTOR_TRIM;
  
  rightMotorSpeed -= steeringCorrection;
  leftMotorSpeed += steeringCorrection;
  
  rightMotorSpeed = constrain(rightMotorSpeed, 30, 150);
  leftMotorSpeed = constrain(leftMotorSpeed, 30, 150);
  
  controlMotor(rightMotorSpeed, leftMotorSpeed);
  
  Serial.print("Wall distance: ");
  Serial.print(sideDistance);
  Serial.print(" cm, Error: ");
  Serial.println(error);
}

// Wall following with corner detection
void followWallWithCorners() {
  float sideDistance = getDistance(TRIG_PIN_SIDE, ECHO_PIN_SIDE);
  float frontDistance = getDistance(TRIG_PIN_FRONT, ECHO_PIN_FRONT);
  
  // Debug output
  Serial.print("Side: ");
  Serial.print(sideDistance);
  Serial.print(" cm | Front: ");
  Serial.print(frontDistance);
  Serial.print(" cm | State: ");
  
  // Print state name
  switch(cornerState) {
    case FOLLOWING: Serial.print("FOLLOWING"); break;
    case INSIDE_CORNER_PAUSE_BEFORE: Serial.print("IN_PAUSE_BEFORE"); break;
    case INSIDE_CORNER_TURN: Serial.print("IN_TURNING"); break;
    case INSIDE_CORNER_PAUSE_AFTER: Serial.print("IN_PAUSE_AFTER"); break;
    case OUTSIDE_CORNER_PAUSE_BEFORE: Serial.print("OUT_PAUSE_BEFORE"); break;
    case OUTSIDE_CORNER_TURN: Serial.print("OUT_TURNING"); break;
    case OUTSIDE_CORNER_DRIVE_FORWARD: Serial.print("OUT_DRIVING"); break;
    case OUTSIDE_CORNER_PAUSE_AFTER: Serial.print("OUT_PAUSE_AFTER"); break;
  }
  Serial.print(" | ");
  
  // Handle corner state machine
  if (cornerState != FOLLOWING) {
    handleCornerState(sideDistance, frontDistance);
    return;
  }
  
  // Check for invalid side sensor reading ONLY when in normal following mode
  if (sideDistance < 0 || sideDistance > 150) {
    stopRobot();
    Serial.println("Lost wall sensor");
    return;
  }
  
  // OUTSIDE CORNER DETECTION FIRST - Wall disappears on right side
  // This is PRIORITY because it's more critical
  if (sideDistance > OUTSIDE_CORNER_THRESHOLD) {
    if (millis() - lastCornerTime < CORNER_COOLDOWN) {
      Serial.println("Outside corner detected but in cooldown - ignoring");
    } else {
      Serial.println(">>> OUTSIDE CORNER DETECTED - Wall disappeared!");
      stopRobot();
      cornerState = OUTSIDE_CORNER_PAUSE_BEFORE;
      cornerStartTime = millis();
      return;
    }
  }
  
  // INSIDE CORNER DETECTION - Front obstacle AND wall still present on side
  if (frontDistance > 0 && frontDistance < INSIDE_CORNER_THRESHOLD &&
      sideDistance < LOST_WALL_THRESHOLD) {
    if (millis() - lastCornerTime < CORNER_COOLDOWN) {
      Serial.println("Inside corner detected but in cooldown - ignoring");
    } else {
      Serial.println(">>> INSIDE CORNER DETECTED - Front obstacle!");
      stopRobot();
      cornerState = INSIDE_CORNER_PAUSE_BEFORE;
      cornerStartTime = millis();
      return;
    }
  }
  
  // NORMAL WALL FOLLOWING
  Serial.println("Following wall normally");
  
  float error = sideDistance - SET_POINT_WALL;
  float steeringCorrection = Kp_WALL * error;
  
  int rightMotorSpeed = WALL_FORWARD_SPEED - MOTOR_TRIM;
  int leftMotorSpeed = WALL_FORWARD_SPEED + MOTOR_TRIM;
  
  rightMotorSpeed -= steeringCorrection;
  leftMotorSpeed += steeringCorrection;
  
  rightMotorSpeed = constrain(rightMotorSpeed, 30, 150);
  leftMotorSpeed = constrain(leftMotorSpeed, 30, 150);
  
  controlMotor(rightMotorSpeed, leftMotorSpeed);
}

// Handle corner state machine
void handleCornerState(float sideDistance, float frontDistance) {
  unsigned long elapsed = millis() - cornerStartTime;
  
  switch (cornerState) {
    // ===== INSIDE CORNER STATES =====
    case INSIDE_CORNER_PAUSE_BEFORE:
      stopRobot();
      Serial.print("Inside: Pausing before turn... ");
      Serial.println(elapsed);
      if (elapsed > PAUSE_DURATION) {
        Serial.println("Inside: Starting LEFT turn");
        cornerState = INSIDE_CORNER_TURN;
        cornerStartTime = millis();
      }
      break;
      
    case INSIDE_CORNER_TURN:
      // Turn LEFT - right motor fast, left motor slow
      controlMotor(120, 50);
      Serial.print("Inside: Turning LEFT... ");
      Serial.println(elapsed);
      
      // Check if turn complete (either by time OR by seeing wall on side again)
      if (elapsed > TURN_DURATION || 
          (elapsed > 400 && sideDistance > 0 && sideDistance < SET_POINT_WALL + 10)) {
        Serial.println("Inside: Turn complete");
        stopRobot();
        cornerState = INSIDE_CORNER_PAUSE_AFTER;
        cornerStartTime = millis();
      }
      break;
      
    case INSIDE_CORNER_PAUSE_AFTER:
      stopRobot();
      Serial.print("Inside: Pausing after turn... ");
      Serial.println(elapsed);
      if (elapsed > PAUSE_DURATION) {
        Serial.println("Inside: Corner complete - Resuming");
        cornerState = FOLLOWING;
        lastCornerTime = millis();
      }
      break;
    
    // ===== OUTSIDE CORNER STATES =====
    case OUTSIDE_CORNER_PAUSE_BEFORE:
      stopRobot();
      Serial.print("Outside: Pausing before turn... ");
      Serial.println(elapsed);
      if (elapsed > PAUSE_DURATION) {
        Serial.println("Outside: Starting RIGHT turn");
        cornerState = OUTSIDE_CORNER_TURN;
        cornerStartTime = millis();
      }
      break;
      
    case OUTSIDE_CORNER_TURN:
      // Turn RIGHT - Use PIVOT turn for sharper corner
      // Right motor BACKWARD, left motor FORWARD
      controlMotor(-80, 120);  // Pivot turn right
      Serial.print("Outside: Turning RIGHT (pivot)... ");
      Serial.println(elapsed);
      
      if (elapsed > TURN_DURATION) {
        Serial.println("Outside: Turn complete - Driving forward");
        cornerState = OUTSIDE_CORNER_DRIVE_FORWARD;
        cornerStartTime = millis();
      }
      break;
      
    case OUTSIDE_CORNER_DRIVE_FORWARD:
      // Drive straight forward
      controlMotor(80, 80);
      Serial.print("Outside: Driving forward... ");
      Serial.println(elapsed);
      
      // Check if we found the wall again
      if (sideDistance > 0 && sideDistance < OUTSIDE_CORNER_THRESHOLD) {
        Serial.print("Outside: Wall found at ");
        Serial.print(sideDistance);
        Serial.println(" cm - Pausing");
        stopRobot();
        cornerState = OUTSIDE_CORNER_PAUSE_AFTER;
        cornerStartTime = millis();
      } 
      // Or if we've driven long enough
      else if (elapsed > DRIVE_FORWARD_TIME) {
        Serial.println("Outside: Drive timeout - Pausing");
        stopRobot();
        cornerState = OUTSIDE_CORNER_PAUSE_AFTER;
        cornerStartTime = millis();
      }
      break;
      
    case OUTSIDE_CORNER_PAUSE_AFTER:
      stopRobot();
      Serial.print("Outside: Pausing after corner... ");
      Serial.println(elapsed);
      if (elapsed > PAUSE_DURATION) {
        Serial.println("Outside: Corner complete - Resuming");
        cornerState = FOLLOWING;
        lastCornerTime = millis();
      }
      break;
  }
}

// Movement functions
void driveForward(int speed) {
  controlMotor(speed, speed);
}

void driveBackward(int speed) {
  controlMotor(-speed, -speed);
}

void turnLeft(int speed) {
  controlMotor(speed, speed / 2);
}

void turnRight(int speed) {
  controlMotor(speed / 2, speed);
}

void stopRobot() {
  controlMotor(0, 0);
}

void loop() {
  if (Serial.available() > 0) {
    char command = Serial.read();
    
    int v1 = digitalRead(D_1);
    int v2 = digitalRead(D_2);
    
    switch (command) {
      case 'f':
        currentMode = FOLLOW_ME;
        Serial.println("FOLLOW ME MODE ACTIVE");
        break;
        
      case 'g':
        currentMode = WALL_FOLLOW;
        Serial.println("WALL FOLLOW MODE ACTIVE (simple - no corners)");
        break;
        
      case 'c':
        currentMode = WALL_FOLLOW_CORNERS;
        cornerState = FOLLOWING;
        lastCornerTime = 0;  // Reset cooldown
        Serial.println("WALL FOLLOW WITH CORNERS MODE ACTIVE");
        break;
        
      case 't':  // Test sensors
        {
          float front = getDistance(TRIG_PIN_FRONT, ECHO_PIN_FRONT);
          float side = getDistance(TRIG_PIN_SIDE, ECHO_PIN_SIDE);
          Serial.print("Front: ");
          Serial.print(front);
          Serial.print(" cm | Side: ");
          Serial.print(side);
          Serial.println(" cm");
        }
        break;
        
      case 'w':
        currentMode = MANUAL;
        driveForward(65);
        Serial.print("FORWARD | Sensors: ");
        Serial.print(v1); 
        Serial.print(',');
        Serial.println(v2);
        break;
        
      case 's':
        currentMode = MANUAL;
        driveBackward(65);
        Serial.print("BACK | Sensors: ");
        Serial.print(v1); 
        Serial.print(',');
        Serial.println(v2);
        break;
        
      case 'a':
        currentMode = MANUAL;
        turnLeft(50);
        Serial.print("LEFT | Sensors: ");
        Serial.print(v1); 
        Serial.print(',');
        Serial.println(v2);
        break;
        
      case 'd':
        currentMode = MANUAL;
        turnRight(50);
        Serial.print("RIGHT | Sensors: ");
        Serial.print(v1); 
        Serial.print(',');
        Serial.println(v2);
        break;
        
      case 'x':
        currentMode = MANUAL;
        stopRobot();
        Serial.print("STOP | Sensors: ");
        Serial.print(v1); 
        Serial.print(',');
        Serial.println(v2);
        break;
        
      default:
        Serial.println("Commands: f=follow, g=wall, c=wall+corners, t=test, w/s/a/d/x=manual");
        break;
    }
  }
  
  if (currentMode == FOLLOW_ME) {
    followMe();
    delay(50);
  } else if (currentMode == WALL_FOLLOW) {
    followWall();
    delay(50);
  } else if (currentMode == WALL_FOLLOW_CORNERS) {
    followWallWithCorners();
    delay(50);
  } else {
    delay(10);
  }
}
