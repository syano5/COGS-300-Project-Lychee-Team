#include <Servo.h>

// -------------------- Motor Pins --------------------
#define enA 9
#define in1 8
#define in2 7
#define enB 6
#define in3 4
#define in4 5

// -------------------- Ultrasonic Pins --------------------
#define TRIG_PIN_FRONT 10
#define ECHO_PIN_FRONT 11

// -------------------- Servo --------------------
#define SERVO_PIN 3
Servo servo_9;

// -------------------- Object Tracking Constants --------------------
const float DETECTION_RANGE = 150.0;
const float STOP_DISTANCE   = 30.0;
const int BASE_SPEED        = 90;
const int TURN_SPEED        = 80;
const int SWEEP_DELAY       = 15;
const int SWEEP_STEP        = 5;

enum ObjectState { SWEEP, ORIENT, APPROACH, PAUSE };
ObjectState objectState = SWEEP;

int pos = 90;
int sweepDirection = 1;
int objectAngle = 90;
float lastDistance = -1;

// -------------------- Setup --------------------
void setup() {
  Serial.begin(115200);

  pinMode(enA, OUTPUT);
  pinMode(in1, OUTPUT);
  pinMode(in2, OUTPUT);

  pinMode(enB, OUTPUT);
  pinMode(in3, OUTPUT);
  pinMode(in4, OUTPUT);

  pinMode(TRIG_PIN_FRONT, OUTPUT);
  pinMode(ECHO_PIN_FRONT, INPUT);

  servo_9.attach(SERVO_PIN, 500, 2500);
  servo_9.write(90);

  Serial.println("OBJECT-TRACKING MODE READY");
  delay(1000);
}

// -------------------- Main Loop --------------------
void loop() {
  switch (objectState) {
    case SWEEP:     performSweep();     break;
    case ORIENT:    orientToObject();   break;
    case APPROACH:  approachObject();   break;
    case PAUSE:     pauseThenSweep();   break;
  }
  delay(30);
}

// -------------------- OBJECT TRACKING --------------------
void performSweep() {
  servo_9.write(pos);
  delay(SWEEP_DELAY);

  float distance = getDistance();

  Serial.print("Sweep @ ");
  Serial.print(pos);
  Serial.print("°  dist=");
  Serial.println(distance);

  // OBJECT FOUND
  if (distance > 0 && distance <= DETECTION_RANGE) {
    objectAngle = pos;
    lastDistance = distance;
    Serial.println(">>> OBJECT FOUND!");
    objectState = ORIENT;
    return;
  }

  // continue sweeping
  pos += sweepDirection * SWEEP_STEP;

  if (pos >= 180) { pos = 180; sweepDirection = -1; }
  if (pos <= 0)   { pos = 0;   sweepDirection =  1; }
}

void orientToObject() {
  int angleDiff = objectAngle - 90;

  Serial.print("Orienting: angleDiff = ");
  Serial.println(angleDiff);

  if (abs(angleDiff) < 12) {
    Serial.println(">>> Centered. Approach!");
    servo_9.write(90);
    objectState = APPROACH;
    return;
  }

  if (angleDiff < 0)
    turnLeft(TURN_SPEED);
  else
    turnRight(TURN_SPEED);

  delay(abs(angleDiff) * 10);

  stopRobot();
  delay(200);
  servo_9.write(90);
  delay(150);

  float d = getDistance();
  if (d > 0 && d <= DETECTION_RANGE) {
    objectState = APPROACH;
    Serial.println(">>> Object confirmed.");
  } else {
    Serial.println(">>> Object lost. Resuming sweep...");
    objectState = SWEEP;
    pos = 60;
    sweepDirection = 1;
  }
}

void approachObject() {
  float distance = getDistance();

  Serial.print("Approach dist=");
  Serial.println(distance);

  if (distance < 0) {
    Serial.println("Object lost -> resweep");
    objectState = SWEEP;
    pos = 90;
    return;
  }

  if (distance <= STOP_DISTANCE) {
    stopRobot();
    Serial.println(">>> TARGET TOUCH! Tournament complete.");
    objectState = PAUSE;
    return;
  }

  if (distance > DETECTION_RANGE) {
    Serial.println("Out of range -> sweep");
    objectState = SWEEP;
    pos = 90;
    return;
  }

  driveForward(BASE_SPEED);
}

// -------------------- Pause Mode --------------------
void pauseThenSweep() {
  stopRobot();
  Serial.println("Standing by...");
  delay(1000);
}

// -------------------- Utilities --------------------
float getDistance() {
  digitalWrite(TRIG_PIN_FRONT, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN_FRONT, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN_FRONT, LOW);

  long duration = pulseIn(ECHO_PIN_FRONT, HIGH, 30000);
  if (duration == 0) return -1;
  return duration * 0.034 / 2.0;
}

// Corrected motor directions (your updated version)
void controlMotor(int leftSpeed, int rightSpeed) {

  // LEFT MOTOR (A)
  if (leftSpeed >= 0) {
    digitalWrite(in1, HIGH);
    digitalWrite(in2, LOW);
  } else {
    digitalWrite(in1, LOW);
    digitalWrite(in2, HIGH);
    leftSpeed = -leftSpeed;
  }
  analogWrite(enA, constrain(leftSpeed, 0, 255));

  // RIGHT MOTOR (B) — YOUR FIX APPLIED
  if (rightSpeed >= 0) {
    digitalWrite(in3, LOW);
    digitalWrite(in4, HIGH);
  } else {
    digitalWrite(in3, HIGH);
    digitalWrite(in4, LOW);
    rightSpeed = -rightSpeed;
  }
  analogWrite(enB, constrain(rightSpeed, 0, 255));
}

void driveForward(int speed) {
  controlMotor(speed, speed);
}

void turnLeft(int speed) {
  controlMotor(-speed, speed);
}

void turnRight(int speed) {
  controlMotor(speed, -speed);
}

void stopRobot() {
  controlMotor(0, 0);
}
