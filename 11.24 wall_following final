// Motor pins
#define enA 3
#define in1 8
#define in2 7
#define enB 6
#define in3 5
#define in4 4

// Ultrasonic sensors
#define TRIG_FRONT 10
#define ECHO_FRONT 11
#define TRIG_RIGHT 12
#define ECHO_RIGHT 13

// Sensor pins
const int D_1 = 2, D_2 = 3;

// Settings
const int SPEED = 100;
const int TURN_SPEED = 90;
const float WALL_DISTANCE = 15.0;
const float FRONT_STOP = 20.0;

bool mazeMode = true;  // Auto-start in maze mode
unsigned long lastTurnTime = 0;
const int TURN_DELAY = 1000; // Prevent rapid direction changes

void setup() {
  pinMode(enA, OUTPUT);
  pinMode(enB, OUTPUT);
  pinMode(in1, OUTPUT);
  pinMode(in2, OUTPUT);
  pinMode(in3, OUTPUT);
  pinMode(in4, OUTPUT);
  
  pinMode(TRIG_FRONT, OUTPUT);
  pinMode(ECHO_FRONT, INPUT);
  pinMode(TRIG_RIGHT, OUTPUT);
  pinMode(ECHO_RIGHT, INPUT);
  pinMode(D_1, INPUT_PULLUP);
  pinMode(D_2, INPUT_PULLUP);
  
  Serial.begin(9600);
  Serial.println("MAZE MODE AUTO-START! Commands: x=stop, w/a/s/d=manual, t=test");
  delay(2000);  // 2 second delay before starting
}

float getDistance(int trig, int echo) {
  digitalWrite(trig, LOW);
  delayMicroseconds(2);
  digitalWrite(trig, HIGH);
  delayMicroseconds(10);
  digitalWrite(trig, LOW);
  
  long duration = pulseIn(echo, HIGH, 30000);
  if (duration == 0) return 999;
  
  return duration * 0.034 / 2.0;
}

void setMotors(int leftSpeed, int rightSpeed) {
  // Left motor (Motor B)
  if (leftSpeed > 0) {
    digitalWrite(in3, HIGH);
    digitalWrite(in4, LOW);
    analogWrite(enB, leftSpeed);
  } else if (leftSpeed < 0) {
    digitalWrite(in3, LOW);
    digitalWrite(in4, HIGH);
    analogWrite(enB, -leftSpeed);
  } else {
    digitalWrite(in3, LOW);
    digitalWrite(in4, LOW);
    analogWrite(enB, 0);
  }
  
  // Right motor (Motor A)
  if (rightSpeed > 0) {
    digitalWrite(in1, HIGH);
    digitalWrite(in2, LOW);
    analogWrite(enA, rightSpeed);
  } else if (rightSpeed < 0) {
    digitalWrite(in1, LOW);
    digitalWrite(in2, HIGH);
    analogWrite(enA, -rightSpeed);
  } else {
    digitalWrite(in1, LOW);
    digitalWrite(in2, LOW);
    analogWrite(enA, 0);
  }
}

void forward(int speed) {
  setMotors(speed, speed);
}

void backward(int speed) {
  setMotors(-speed, -speed);
}

void turnLeft(int speed) {
  setMotors(-speed, speed);
}

void turnRight(int speed) {
  setMotors(speed, -speed);
}

void stop() {
  setMotors(0, 0);
}

void mazeSolve() {
  float front = getDistance(TRIG_FRONT, ECHO_FRONT);
  float right = getDistance(TRIG_RIGHT, ECHO_RIGHT);
  
  Serial.print("Front: ");
  Serial.print(front);
  Serial.print(" cm, Right: ");
  Serial.print(right);
  Serial.println(" cm");
  
  // Filter out invalid readings
  if (front > 400) front = 400;
  if (right > 400) right = 400;
  
  unsigned long currentTime = millis();
  
  // Priority 1: Front obstacle - stop, back up, then turn
  if (front < FRONT_STOP) {
    Serial.println("Front blocked!");
    stop();
    delay(200);
    backward(SPEED);
    delay(300);
    stop();
    delay(200);
    turnLeft(TURN_SPEED);
    delay(500);
    stop();
    lastTurnTime = currentTime;
    return;
  }
  
  // Priority 2: Right wall lost (opening detected)
  if (right > 40 && (currentTime - lastTurnTime > TURN_DELAY)) {
    Serial.println("Right opening!");
    forward(SPEED);
    delay(300);
    turnRight(TURN_SPEED);
    delay(400);
    stop();
    lastTurnTime = currentTime;
    return;
  }
  
  // Priority 3: Wall following with proportional control
  if (right < 200) {  // Only follow if wall is detected
    float error = right - WALL_DISTANCE;
    int adjustment = constrain(error * 3, -40, 40);
    
    int leftSpeed = SPEED - adjustment;
    int rightSpeed = SPEED + adjustment;
    
    // Constrain speeds
    leftSpeed = constrain(leftSpeed, 60, 140);
    rightSpeed = constrain(rightSpeed, 60, 140);
    
    setMotors(leftSpeed, rightSpeed);
  } else {
    // No wall detected, go straight
    forward(SPEED);
  }
}

void loop() {
  if (Serial.available()) {
    char cmd = Serial.read();
    
    switch (cmd) {
      case 'm':
        mazeMode = true;
        lastTurnTime = millis();
        Serial.println("MAZE MODE ON");
        break;
        
      case 'w':
        mazeMode = false;
        forward(SPEED);
        Serial.println("Forward");
        break;
        
      case 's':
        mazeMode = false;
        backward(SPEED);
        Serial.println("Backward");
        break;
        
      case 'a':
        mazeMode = false;
        turnLeft(TURN_SPEED);
        Serial.println("Left");
        break;
        
      case 'd':
        mazeMode = false;
        turnRight(TURN_SPEED);
        Serial.println("Right");
        break;
        
      case 'x':
        mazeMode = false;
        stop();
        Serial.println("Stop");
        break;
        
      case 't':
        Serial.print("Front: ");
        Serial.print(getDistance(TRIG_FRONT, ECHO_FRONT));
        Serial.print(" cm, Right: ");
        Serial.print(getDistance(TRIG_RIGHT, ECHO_RIGHT));
        Serial.println(" cm");
        break;
    }
  }
  
  if (mazeMode) {
    mazeSolve();
    delay(50);
  }
}
