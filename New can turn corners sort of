#define enA 9
#define in1 8
#define in2 7
#define enB 6
#define in3 5
#define in4 4

#define TRIG_PIN_FRONT 10
#define ECHO_PIN_FRONT 11
#define TRIG_PIN_SIDE 12
#define ECHO_PIN_SIDE 13

const int D_1 = 2, D_2 = 3;

// Wall following parameters
const float SET_POINT_WALL = 18.0;        // Target distance from wall (cm)
const float Kp_WALL = 3.5;                // Proportional gain (lower for smoother)
const int BASE_SPEED = 65;                // Base forward speed (slower)
const float DEADBAND = 10.0;              // Error deadband for straight driving (cm) - WIDE!

// Safe operating range - only correct if within this range
const float MIN_WALL_DISTANCE = 6.0;      // Too close to wall
const float MAX_WALL_DISTANCE = 40.0;     // Too far / losing wall (increased from 35)

// Corner detection
const float CORNER_DETECTION_THRESHOLD = 45.0;  // Wall distance that triggers corner turn
const int CORNER_TURN_SPEED = 60;              // Speed while turning at corner (slower)
const unsigned long CORNER_TURN_DURATION = 900; // How long to turn (ms) - longer turn
const unsigned long SEARCH_FORWARD_DURATION = 2500; // How long to drive forward after turn (ms)
const unsigned long RECENT_TURN_WINDOW = 4000;  // Time window to consider a turn "recent" (ms)

// Wall loss detection
const unsigned long WALL_LOSS_TIMEOUT = 2000;  // Stop if no wall detected for 2 seconds

// Front obstacle detection
const float FRONT_OBSTACLE_THRESHOLD = 25.0;    // Stop if obstacle this close
const float INSIDE_CORNER_THRESHOLD = 18.0;     // Turn left for inside corner (reduced from 20)
const float INSIDE_CORNER_MIN = 12.0;           // Minimum distance to trigger inside corner (increased from 10)

enum Mode {
  MANUAL,
  FOLLOW_ME,
  WALL_FOLLOW
};

enum CornerState {
  NORMAL_FOLLOWING,
  PRE_TURN_PAUSE,
  TURNING,
  POST_TURN_PAUSE,
  SEARCH_FORWARD,
  INSIDE_PRE_TURN_PAUSE,
  INSIDE_CORNER_TURN,
  INSIDE_POST_TURN_PAUSE
};

Mode currentMode = MANUAL;
CornerState cornerState = NORMAL_FOLLOWING;
unsigned long cornerStateStartTime = 0;
unsigned long lastTurnCompletedTime = 0;  // Track when we last completed a turn
unsigned long lastValidWallTime = 0;      // Track when we last saw a valid wall reading
unsigned long wallFollowStartTime = 0;    // Track when wall following started

void setup() {
  pinMode(enA, OUTPUT);
  pinMode(in1, OUTPUT);
  pinMode(in2, OUTPUT);
  pinMode(enB, OUTPUT);
  pinMode(in3, OUTPUT);
  pinMode(in4, OUTPUT);
  pinMode(TRIG_PIN_FRONT, OUTPUT);
  pinMode(ECHO_PIN_FRONT, INPUT);
  pinMode(TRIG_PIN_SIDE, OUTPUT);
  pinMode(ECHO_PIN_SIDE, INPUT);
  pinMode(D_1, INPUT_PULLUP);
  pinMode(D_2, INPUT_PULLUP);
  
  Serial.begin(9600);
  Serial.println("Wall Following Robot Ready!");
  Serial.println("Commands: g=wall follow, w/s/a/d/x=manual, t=test sensors");
}

float getDistance(int trigPin, int echoPin) {
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  
  long duration = pulseIn(echoPin, HIGH, 30000);
  if (duration == 0) return -1;
  
  return duration * 0.034 / 2.0;
}

void controlMotor(int motorA_speed, int motorB_speed) {
  // Motor A (right)
  if (motorA_speed >= 0) {
    digitalWrite(in1, HIGH);
    digitalWrite(in2, LOW);
  } else {
    digitalWrite(in1, LOW);
    digitalWrite(in2, HIGH);
    motorA_speed = -motorA_speed;
  }
  analogWrite(enA, constrain(motorA_speed, 0, 255));
  
  // Motor B (left)
  if (motorB_speed >= 0) {
    digitalWrite(in3, HIGH);
    digitalWrite(in4, LOW);
  } else {
    digitalWrite(in3, LOW);
    digitalWrite(in4, HIGH);
    motorB_speed = -motorB_speed;
  }
  analogWrite(enB, constrain(motorB_speed, 0, 255));
}

void followWall() {
  float wallDistance = getDistance(TRIG_PIN_SIDE, ECHO_PIN_SIDE);
  float frontDistance = getDistance(TRIG_PIN_FRONT, ECHO_PIN_FRONT);
  
  // Handle corner turning state machine FIRST (highest priority)
  if (cornerState != NORMAL_FOLLOWING) {
    unsigned long elapsedTime = millis() - cornerStateStartTime;
    
    switch (cornerState) {
      case PRE_TURN_PAUSE:
        stopRobot();
        Serial.println(">>> PAUSED BEFORE TURN <<<");
        if (elapsedTime >= 1000) {  // 1 second pause
          cornerState = TURNING;
          cornerStateStartTime = millis();
          Serial.println(">>> STARTING TURN <<<");
        }
        return;
        
      case TURNING:
        controlMotor(-CORNER_TURN_SPEED, CORNER_TURN_SPEED);
        Serial.println(">>> TURNING RIGHT <<<");
        if (elapsedTime >= CORNER_TURN_DURATION) {
          cornerState = POST_TURN_PAUSE;
          cornerStateStartTime = millis();
        }
        return;
        
      case POST_TURN_PAUSE:
        stopRobot();
        Serial.println(">>> PAUSED AFTER TURN <<<");
        if (elapsedTime >= 1000) {  // 1 second pause
          cornerState = SEARCH_FORWARD;
          cornerStateStartTime = millis();
          Serial.println(">>> SEARCHING FOR WALL - MOVING FORWARD <<<");
        }
        return;
        
      case SEARCH_FORWARD:
        {
          // Drive straight forward to find the wall
          controlMotor(BASE_SPEED, BASE_SPEED);
          
          // Check if we found the wall again
          float searchDistance = getDistance(TRIG_PIN_SIDE, ECHO_PIN_SIDE);
          if (searchDistance > 0 && searchDistance < MAX_WALL_DISTANCE) {
            Serial.print(">>> WALL FOUND at ");
            Serial.print(searchDistance);
            Serial.println(" cm - RESUMING WALL FOLLOW <<<");
            cornerState = NORMAL_FOLLOWING;
            lastTurnCompletedTime = millis();  // Mark turn as complete
            lastValidWallTime = millis();      // Reset wall loss timer
            return;
          }
          
          // Or timeout after driving forward for a while
          if (elapsedTime >= SEARCH_FORWARD_DURATION) {
            Serial.println(">>> SEARCH TIMEOUT - RESUMING WALL FOLLOW <<<");
            cornerState = NORMAL_FOLLOWING;
            lastTurnCompletedTime = millis();  // Mark turn as complete
          }
          return;
        }
        
      case INSIDE_PRE_TURN_PAUSE:
        {
          stopRobot();
          Serial.println(">>> PAUSED BEFORE LEFT TURN <<<");
          
          // Re-check front sensor before committing to turn
          float recheckFront = getDistance(TRIG_PIN_FRONT, ECHO_PIN_FRONT);
          Serial.print("Re-checking front: ");
          Serial.print(recheckFront);
          Serial.println(" cm");
          
          if (elapsedTime >= 1000) {  // 1 second pause
            // Only turn if obstacle is still there
            if (recheckFront > 0 && recheckFront >= INSIDE_CORNER_MIN && recheckFront <= INSIDE_CORNER_THRESHOLD) {
              cornerState = INSIDE_CORNER_TURN;
              cornerStateStartTime = millis();
              Serial.println(">>> STARTING LEFT TURN <<<");
            } else {
              // False alarm - no obstacle, resume normal following
              Serial.println(">>> FALSE ALARM - NO OBSTACLE - RESUMING <<<");
              cornerState = NORMAL_FOLLOWING;
              lastValidWallTime = millis();
            }
          }
          return;
        }
        
      case INSIDE_CORNER_TURN:
        {
          // Turn left for inside corner
          controlMotor(CORNER_TURN_SPEED, -CORNER_TURN_SPEED);
          Serial.println(">>> TURNING LEFT (INSIDE CORNER) <<<");
          
          // Check if we've turned enough (look for clear path ahead)
          float checkFront = getDistance(TRIG_PIN_FRONT, ECHO_PIN_FRONT);
          if (checkFront > INSIDE_CORNER_THRESHOLD || checkFront < 0) {
            // Path is clear or no reading (turned away from wall)
            cornerState = INSIDE_POST_TURN_PAUSE;
            cornerStateStartTime = millis();
            Serial.println(">>> LEFT TURN COMPLETE <<<");
            return;
          }
          
          // Safety timeout - don't turn forever
          if (elapsedTime >= 1500) {
            Serial.println(">>> INSIDE CORNER TIMEOUT <<<");
            cornerState = INSIDE_POST_TURN_PAUSE;
            cornerStateStartTime = millis();
          }
          return;
        }
        
      case INSIDE_POST_TURN_PAUSE:
        {
          stopRobot();
          Serial.println(">>> PAUSED AFTER LEFT TURN <<<");
          if (elapsedTime >= 1000) {  // 1 second pause
            cornerState = NORMAL_FOLLOWING;
            lastValidWallTime = millis();
            Serial.println(">>> RESUMING WALL FOLLOW <<<");
          }
          return;
        }
    }
  }
  
  // Check for invalid/no wall reading
  // If we recently turned (within 4 seconds), drive forward instead of turning again
  bool recentlyTurned = (millis() - lastTurnCompletedTime) < RECENT_TURN_WINDOW;
  
  if (wallDistance < 0 && cornerState == NORMAL_FOLLOWING) {
    // Check if we've lost the wall for too long (2 seconds)
    if (millis() - lastValidWallTime > WALL_LOSS_TIMEOUT) {
      stopRobot();
      currentMode = MANUAL;
      Serial.println("!!! WALL LOST FOR 2+ SECONDS - STOPPED !!!");
      Serial.println("!!! Press 'g' to restart wall following !!!");
      return;
    }
    
    if (recentlyTurned) {
      // Just turned recently, so drive forward to find wall
      Serial.println("No wall detected but recently turned - driving forward to search");
      controlMotor(BASE_SPEED, BASE_SPEED);
      return;
    } else {
      // Haven't turned recently, this is a new outside corner
      Serial.println("OUTSIDE CORNER DETECTED! No wall reading (sensor sees nothing)");
      cornerState = PRE_TURN_PAUSE;
      cornerStateStartTime = millis();
      stopRobot();
      return;
    }
  }
  
  // If we have a valid wall reading, update the timer
  if (wallDistance > 0) {
    lastValidWallTime = millis();
  }
  
  // If no reading and we're already handling corner, just continue
  if (wallDistance < 0) {
    return;  // Let the state machine handle it
  }
  
  // OUTSIDE CORNER DETECTION
  // Only trigger if distance is WAY beyond normal operating range
  // AND we haven't recently turned
  if (wallDistance > CORNER_DETECTION_THRESHOLD && cornerState == NORMAL_FOLLOWING) {
    if (recentlyTurned) {
      // Just turned recently, so drive forward to find wall
      Serial.print("Far from wall (");
      Serial.print(wallDistance);
      Serial.println(" cm) but recently turned - driving forward to search");
      controlMotor(BASE_SPEED, BASE_SPEED);
      return;
    } else {
      // New outside corner detected
      Serial.print("OUTSIDE CORNER DETECTED! Wall distance: ");
      Serial.print(wallDistance);
      Serial.println(" cm");
      cornerState = PRE_TURN_PAUSE;
      cornerStateStartTime = millis();
      stopRobot();
      return;
    }
  }
  
  // Check for front obstacle or inside corner (AFTER outside corner checks)
  // Only check after robot has been running for 2 seconds to avoid startup false positives
  if (millis() - wallFollowStartTime > 2000) {
    if (frontDistance > 0 && frontDistance >= INSIDE_CORNER_MIN && frontDistance <= INSIDE_CORNER_THRESHOLD) {
      // Inside corner detected - turn left
      if (cornerState == NORMAL_FOLLOWING) {
        Serial.print("INSIDE CORNER DETECTED! Front distance: ");
        Serial.print(frontDistance);
        Serial.println(" cm (12-18cm range) - Preparing to turn left");
        cornerState = INSIDE_PRE_TURN_PAUSE;
        cornerStateStartTime = millis();
      }
    } else if (frontDistance > 0 && frontDistance < INSIDE_CORNER_MIN) {
      // Too close - stop immediately
      stopRobot();
      Serial.print("!!! FRONT OBSTACLE TOO CLOSE (");
      Serial.print(frontDistance);
      Serial.println(" cm) - STOPPED !!!");
      return;
    }
  }
  
  if (wallDistance > MAX_WALL_DISTANCE) {
    // Getting far but not corner - turn right gently to find wall
    int leftSpeed = BASE_SPEED + 20;
    int rightSpeed = BASE_SPEED - 20;
    Serial.print("Drifting from wall: ");
    Serial.print(wallDistance);
    Serial.print(" cm | Speeds L:");
    Serial.print(leftSpeed);
    Serial.print(" R:");
    Serial.print(rightSpeed);
    Serial.println(" - CORRECTING");
    controlMotor(rightSpeed, leftSpeed);
    return;
  }
  
  // Normal wall following with P-controller (within safe range)
  float error = wallDistance - SET_POINT_WALL;
  
  // Apply deadband for straighter driving
  if (abs(error) < DEADBAND) {
    // Drive straight
    controlMotor(BASE_SPEED, BASE_SPEED);
    Serial.print("Straight | Wall: ");
    Serial.print(wallDistance);
    Serial.print(" cm | Speeds L:");
    Serial.print(BASE_SPEED);
    Serial.print(" R:");
    Serial.println(BASE_SPEED);
  } else {
    // Calculate steering correction
    float steeringCorrection = Kp_WALL * error;
    
    // Apply differential steering
    // Positive error (too far) = turn right (reduce right motor)
    // Negative error (too close) = turn left (reduce left motor)
    int rightMotorSpeed = BASE_SPEED - steeringCorrection;
    int leftMotorSpeed = BASE_SPEED + steeringCorrection;
    
    // Compensate for left drift - give right motor a bit more power
    rightMotorSpeed += 3;
    leftMotorSpeed -= 3;
    
    // Constrain to safe ranges
    rightMotorSpeed = constrain(rightMotorSpeed, 30, 110);
    leftMotorSpeed = constrain(leftMotorSpeed, 30, 110);
    
    controlMotor(rightMotorSpeed, leftMotorSpeed);
    
    Serial.print("Wall: ");
    Serial.print(wallDistance);
    Serial.print(" cm | Err: ");
    Serial.print(error);
    Serial.print(" | Speeds L:");
    Serial.print(leftMotorSpeed);
    Serial.print(" R:");
    Serial.println(rightMotorSpeed);
  }
}

void followMe() {
  float distance = getDistance(TRIG_PIN_FRONT, ECHO_PIN_FRONT);
  const float SET_POINT = 25.0;
  const float Kp = 8.0;
  
  if (distance < 0 || distance > 100) {
    stopRobot();
    return;
  }
  
  float error = distance - SET_POINT;
  int motorSpeed = constrain((int)(Kp * error), -200, 200);
  
  if (abs(error) < 2.0) {
    stopRobot();
  } else {
    if (motorSpeed > 0 && motorSpeed < 50) motorSpeed = 50;
    else if (motorSpeed < 0 && motorSpeed > -50) motorSpeed = -50;
    controlMotor(motorSpeed, motorSpeed);
  }
}

void driveForward(int speed) { controlMotor(speed, speed); }
void driveBackward(int speed) { controlMotor(-speed, -speed); }
void turnLeft(int speed) { controlMotor(speed, speed / 2); }
void turnRight(int speed) { controlMotor(speed / 2, speed); }
void stopRobot() { controlMotor(0, 0); }

void loop() {
  if (Serial.available() > 0) {
    char command = Serial.read();
    int v1 = digitalRead(D_1);
    int v2 = digitalRead(D_2);
    
    switch (command) {
      case 'g':
        currentMode = WALL_FOLLOW;
        cornerState = NORMAL_FOLLOWING;
        lastValidWallTime = millis();  // Reset wall loss timer
        wallFollowStartTime = millis(); // Reset startup timer
        Serial.println("=== WALL FOLLOW MODE ACTIVE ===");
        Serial.println("Inside corner detection disabled for first 2 seconds...");
        break;
      case 'f':
        currentMode = FOLLOW_ME;
        Serial.println("=== FOLLOW ME MODE ===");
        break;
      case 't':
        Serial.print("Side: ");
        Serial.print(getDistance(TRIG_PIN_SIDE, ECHO_PIN_SIDE));
        Serial.print(" cm | Front: ");
        Serial.print(getDistance(TRIG_PIN_FRONT, ECHO_PIN_FRONT));
        Serial.println(" cm");
        break;
      case 'w':
        currentMode = MANUAL;
        driveForward(65);
        Serial.println("FORWARD");
        break;
      case 's':
        currentMode = MANUAL;
        driveBackward(65);
        Serial.println("BACKWARD");
        break;
      case 'a':
        currentMode = MANUAL;
        turnLeft(50);
        Serial.println("LEFT");
        break;
      case 'd':
        currentMode = MANUAL;
        turnRight(50);
        Serial.println("RIGHT");
        break;
      case 'x':
        currentMode = MANUAL;
        stopRobot();
        Serial.println("STOP");
        break;
    }
  }
  
  if (currentMode == WALL_FOLLOW) {
    followWall();
    delay(50);
  } else if (currentMode == FOLLOW_ME) {
    followMe();
    delay(50);
  } else {
    delay(10);
  }
}
