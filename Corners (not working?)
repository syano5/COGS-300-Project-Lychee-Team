#define enA 9  // Enable pin for Motor A (right motor), PWM compatible
#define in1 8  // Direction control pin 1 for Motor A
#define in2 7  // Direction control pin 2 for Motor A 
#define enB 6  // Enable pin for Motor B (left motor), PWM compatible
#define in3 5  // Direction control pin 1 for Motor B
#define in4 4  // Direction control pin 2 for Motor B

// Front ultrasonic sensor (for obstacle/corner detection)
#define TRIG_PIN_FRONT 10
#define ECHO_PIN_FRONT 11

// Right side ultrasonic sensor (for wall following)
#define TRIG_PIN_SIDE 12
#define ECHO_PIN_SIDE 13

const int D_1 = 2, D_2 = 3;

// P-controller parameters for Follow Me mode
const float SET_POINT_FOLLOW = 25.0;
const float Kp_FOLLOW = 8.0;

// Wall following parameters
const float SET_POINT_WALL = 15.0;    // Target distance from wall - KEEPS THIS DISTANCE
const float Kp_WALL = 5.0;            // Proportional gain - how aggressively it corrects
const int WALL_FORWARD_SPEED = 70;    // Base forward speed
const int MOTOR_TRIM = 10;             // Adjust if robot drifts: positive = speeds up left motor

// Corner detection thresholds
const float INSIDE_CORNER_THRESHOLD = 10.0;   // Front obstacle closer than this = inside corner (closer = less sensitive)
const float OUTSIDE_CORNER_THRESHOLD = 80.0;  // Side wall farther than this = outside corner (farther = less sensitive)
const float LOST_WALL_THRESHOLD = 100.0;       // Side wall farther than this = completely lost wall

const int MAX_SPEED = 150;
const int MIN_SPEED = 50;

// Operating modes
enum Mode {
  MANUAL,
  FOLLOW_ME,
  WALL_FOLLOW,
  WALL_FOLLOW_CORNERS
};

Mode currentMode = MANUAL;

// Corner handling state
enum CornerState {
  FOLLOWING,
  INSIDE_CORNER_PAUSE_BEFORE,
  INSIDE_CORNER_TURN,
  INSIDE_CORNER_PAUSE_AFTER,
  OUTSIDE_CORNER_PAUSE_BEFORE,
  OUTSIDE_CORNER_TURN,
  OUTSIDE_CORNER_DRIVE_FORWARD,
  OUTSIDE_CORNER_PAUSE_AFTER,
  OUTSIDE_CORNER_SEARCHING  // New state: driving forward looking for wall
};

CornerState cornerState = FOLLOWING;
unsigned long cornerStartTime = 0;
unsigned long lastCornerTime = 0;  // Track when last corner was completed
float distanceTraveled = 0;  // Track distance traveled after outside corner
const int PAUSE_DURATION = 1000;  // Pause for 1000ms (1 second)
const int OUTSIDE_CORNER_DRIVE_TIME = 800;  // Drive forward for 800ms after outside turn
const int WALL_SEARCH_TIME = 2000;  // Keep driving forward for up to 2 seconds looking for wall
const int CORNER_COOLDOWN = 1500;  // Wait 1.5 seconds after corner before detecting new corners
const float OUTSIDE_CORNER_DRIVE_DISTANCE = 40.0;  // Drive 40cm forward after outside turn

// Note:
// in1 HIGH and in2 LOW --> FORWARDS
// in1 LOW and in2 HIGH --> BACKWARDS

void setup() {
  pinMode(enA, OUTPUT);
  pinMode(in1, OUTPUT);
  pinMode(in2, OUTPUT);
  pinMode(enB, OUTPUT);
  pinMode(in3, OUTPUT);
  pinMode(in4, OUTPUT);
  
  pinMode(TRIG_PIN_FRONT, OUTPUT);
  pinMode(ECHO_PIN_FRONT, INPUT);
  pinMode(TRIG_PIN_SIDE, OUTPUT);
  pinMode(ECHO_PIN_SIDE, INPUT);
  
  pinMode(D_1, INPUT_PULLUP);
  pinMode(D_2, INPUT_PULLUP);
  
  Serial.begin(9600);
  Serial.println("Robot ready!");
  Serial.println("Commands:");
  Serial.println("  w/s/a/d/x = Manual control");
  Serial.println("  f = Follow Me mode");
  Serial.println("  g = Wall Follow mode (simple)");
  Serial.println("  c = Wall Follow WITH corner detection");
}

// Measure distance using specified sensor
float getDistance(int trigPin, int echoPin) {
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  
  long duration = pulseIn(echoPin, HIGH, 30000);
  
  if (duration == 0) {
    return -1;
  }
  
  float distance = duration * 0.034 / 2.0;
  return distance;
}

// Low-level motor control
void controlMotor(int motorA_speed, int motorB_speed) {
  // Motor A (right motor)
  if (motorA_speed >= 0) {
    digitalWrite(in1, HIGH);
    digitalWrite(in2, LOW);
  } else {
    digitalWrite(in1, LOW);
    digitalWrite(in2, HIGH);
    motorA_speed = -motorA_speed;
  }
  analogWrite(enA, constrain(motorA_speed, 0, 255));
  
  // Motor B (left motor)
  if (motorB_speed >= 0) {
    digitalWrite(in3, HIGH);
    digitalWrite(in4, LOW);
  } else {
    digitalWrite(in3, LOW);
    digitalWrite(in4, HIGH);
    motorB_speed = -motorB_speed;
  }
  analogWrite(enB, constrain(motorB_speed, 0, 255));
}

// Follow Me mode
void followMe() {
  float distance = getDistance(TRIG_PIN_FRONT, ECHO_PIN_FRONT);
  
  if (distance < 0 || distance > 100) {
    stopRobot();
    Serial.print("No object detected (distance: ");
    Serial.print(distance);
    Serial.println(" cm)");
    return;
  }
  
  float error = distance - SET_POINT_FOLLOW;
  float output = Kp_FOLLOW * error;
  int motorSpeed = constrain((int)output, -MAX_SPEED, MAX_SPEED);
  
  if (motorSpeed > 0 && motorSpeed < MIN_SPEED) {
    motorSpeed = MIN_SPEED;
  } else if (motorSpeed < 0 && motorSpeed > -MIN_SPEED) {
    motorSpeed = -MIN_SPEED;
  }
  
  if (abs(error) < 2.0) {
    stopRobot();
    Serial.print("At target: ");
    Serial.print(distance);
    Serial.println(" cm");
  } else {
    controlMotor(motorSpeed, motorSpeed);
    
    Serial.print("Distance: ");
    Serial.print(distance);
    Serial.print(" cm, Error: ");
    Serial.print(error);
    Serial.print(" cm, Speed: ");
    Serial.println(motorSpeed);
  }
}

// Simple wall following (no corner detection)
void followWall() {
  float sideDistance = getDistance(TRIG_PIN_SIDE, ECHO_PIN_SIDE);
  
  if (sideDistance < 0 || sideDistance > 100) {
    stopRobot();
    Serial.println("Lost wall sensor");
    return;
  }
  
  float error = sideDistance - SET_POINT_WALL;
  float steeringCorrection = Kp_WALL * error;
  
  int rightMotorSpeed = WALL_FORWARD_SPEED - MOTOR_TRIM;  // Subtract trim from right
  int leftMotorSpeed = WALL_FORWARD_SPEED + MOTOR_TRIM;   // Add trim to left (speeds it up)
  
  rightMotorSpeed -= steeringCorrection;
  leftMotorSpeed += steeringCorrection;
  
  rightMotorSpeed = constrain(rightMotorSpeed, 30, 150);
  leftMotorSpeed = constrain(leftMotorSpeed, 30, 150);
  
  controlMotor(rightMotorSpeed, leftMotorSpeed);
  
  Serial.print("Wall distance: ");
  Serial.print(sideDistance);
  Serial.print(" cm, Error: ");
  Serial.println(error);
}

// Wall following with corner detection
void followWallWithCorners() {
  float sideDistance = getDistance(TRIG_PIN_SIDE, ECHO_PIN_SIDE);
  float frontDistance = getDistance(TRIG_PIN_FRONT, ECHO_PIN_FRONT);
  
  // Debug output
  Serial.print("Side: ");
  Serial.print(sideDistance);
  Serial.print(" cm | Front: ");
  Serial.print(frontDistance);
  Serial.print(" cm | State: ");
  Serial.print(cornerState);
  Serial.print(" | ");
  
  // Check for invalid side sensor reading ONLY when in normal following mode
  if (cornerState == FOLLOWING && (sideDistance < 0 || sideDistance > 100)) {
    stopRobot();
    Serial.println("Lost wall sensor");
    return;
  }
  
  // INSIDE CORNER DETECTION: Front sensor detects obstacle
  // But only if we're not in a cooldown period from a recent corner
  if (cornerState == FOLLOWING && frontDistance > 0 && frontDistance < INSIDE_CORNER_THRESHOLD) {
    // Check cooldown period
    if (millis() - lastCornerTime < CORNER_COOLDOWN) {
      Serial.println("Inside corner detected but in cooldown period - ignoring");
      // Continue normal following
    } else {
      // First time detecting corner - pause before turning
      Serial.println("INSIDE CORNER DETECTED - Pausing before turn");
      stopRobot();
      cornerState = INSIDE_CORNER_PAUSE_BEFORE;
      cornerStartTime = millis();
      return;
    }
  }
  
  // Handle inside corner states
  if (cornerState >= INSIDE_CORNER_PAUSE_BEFORE && cornerState <= INSIDE_CORNER_PAUSE_AFTER) {
    switch (cornerState) {
      case INSIDE_CORNER_PAUSE_BEFORE:
        // Wait for pause duration
        stopRobot();
        Serial.print("Inside corner pausing... ");
        Serial.println(millis() - cornerStartTime);
        if (millis() - cornerStartTime > PAUSE_DURATION) {
          Serial.println("Starting left turn");
          cornerState = INSIDE_CORNER_TURN;
          cornerStartTime = millis();
        }
        break;
        
      case INSIDE_CORNER_TURN:
        // Execute left turn
        controlMotor(100, 40);  // Right motor fast, left motor slow
        
        // Check if turn is complete
        if (millis() - cornerStartTime > 1000 && sideDistance > 0 && sideDistance < SET_POINT_WALL + 10) {
          Serial.println("Turn complete - Pausing after turn");
          stopRobot();
          cornerState = INSIDE_CORNER_PAUSE_AFTER;
          cornerStartTime = millis();
        }
        break;
        
      case INSIDE_CORNER_PAUSE_AFTER:
        // Pause after turn
        stopRobot();
        if (millis() - cornerStartTime > PAUSE_DURATION) {
          Serial.println("Inside corner complete - Resuming");
          cornerState = FOLLOWING;
          lastCornerTime = millis();  // Record when corner completed
        }
        break;
    }
    return;
  }
  
  // OUTSIDE CORNER DETECTION: Side wall suddenly disappears
  // This happens when the wall ends and robot needs to turn right to follow it around the corner
  if (cornerState == FOLLOWING && sideDistance > OUTSIDE_CORNER_THRESHOLD) {
    // First time detecting corner - pause before turning
    Serial.println("OUTSIDE CORNER DETECTED - Wall disappeared on right side");
    Serial.println("Pausing before turn");
    stopRobot();
    cornerState = OUTSIDE_CORNER_PAUSE_BEFORE;
    cornerStartTime = millis();
    return;
  }
  
  // Handle outside corner states
  if (cornerState >= OUTSIDE_CORNER_PAUSE_BEFORE && cornerState <= OUTSIDE_CORNER_SEARCHING) {
    switch (cornerState) {
      case OUTSIDE_CORNER_PAUSE_BEFORE:
        // Wait for pause duration
        stopRobot();
        Serial.print("Outside corner pausing... ");
        Serial.print(millis() - cornerStartTime);
        Serial.print(" / ");
        Serial.println(PAUSE_DURATION);
        if (millis() - cornerStartTime >= PAUSE_DURATION) {
          Serial.println("Starting right turn to find wall");
          cornerState = OUTSIDE_CORNER_TURN;
          cornerStartTime = millis();
        }
        break;
        
      case OUTSIDE_CORNER_TURN:
        // Execute right turn (turning toward where the wall was)
        controlMotor(40, 100);  // Right motor slow, left motor fast
        
        // Turn for a set time - reduced to turn only 90 degrees
        if (millis() - cornerStartTime > 400) {  // Turn for 0.4 seconds (90 degree turn)
          Serial.println("Turn complete - Driving forward to find new wall");
          cornerState = OUTSIDE_CORNER_DRIVE_FORWARD;
          cornerStartTime = millis();
        }
        break;
        
      case OUTSIDE_CORNER_DRIVE_FORWARD:
        {
          // Drive forward to position sensor to detect new wall
          controlMotor(70, 70);  // Drive straight forward
          
          // Calculate approximate distance traveled (speed * time)
          // At speed 70, robot travels roughly 10cm per 200ms
          float elapsedTime = millis() - cornerStartTime;
          distanceTraveled = (elapsedTime / 200.0) * 10.0;  // Rough estimate
          
          Serial.print("Driving forward... distance: ");
          Serial.print(distanceTraveled);
          Serial.println(" cm");
          
          if (distanceTraveled >= OUTSIDE_CORNER_DRIVE_DISTANCE) {
            Serial.println("Driven 40cm - Pausing after outside corner");
            stopRobot();
            cornerState = OUTSIDE_CORNER_PAUSE_AFTER;
            cornerStartTime = millis();
            distanceTraveled = 0;  // Reset
          }
        }
        break;
        
      case OUTSIDE_CORNER_PAUSE_AFTER:
        // Pause after turn
        stopRobot();
        if (millis() - cornerStartTime > PAUSE_DURATION) {
          Serial.println("Now searching for wall while driving forward");
          cornerState = OUTSIDE_CORNER_SEARCHING;
          cornerStartTime = millis();
        }
        break;
        
      case OUTSIDE_CORNER_SEARCHING:
        // Check if we found the wall
        if (sideDistance > 0 && sideDistance < OUTSIDE_CORNER_THRESHOLD) {
          Serial.print("Wall found at ");
          Serial.print(sideDistance);
          Serial.println(" cm - Resuming normal following");
          cornerState = FOLLOWING;
          lastCornerTime = millis();  // Record when corner completed
        } 
        // Safety: if searching too long, give up and resume normal mode
        else if (millis() - cornerStartTime > WALL_SEARCH_TIME) {
          Serial.println("Wall search timeout - Resuming normal mode");
          cornerState = FOLLOWING;
          lastCornerTime = millis();  // Record when corner completed
        }
        // Keep driving straight forward while searching
        else {
          controlMotor(70, 70);  // Drive straight
          Serial.println("Searching for wall...");
        }
        break;
    }
    return;
  }
  
  // NORMAL WALL FOLLOWING (no corners detected)
  cornerState = FOLLOWING;
  Serial.println("Following");
  
  float error = sideDistance - SET_POINT_WALL;
  float steeringCorrection = Kp_WALL * error;
  
  int rightMotorSpeed = WALL_FORWARD_SPEED;
  int leftMotorSpeed = WALL_FORWARD_SPEED;
  
  // Apply steering correction
  rightMotorSpeed -= steeringCorrection;
  leftMotorSpeed += steeringCorrection;
  
  rightMotorSpeed = constrain(rightMotorSpeed, 30, 150);
  leftMotorSpeed = constrain(leftMotorSpeed, 30, 150);
  
  controlMotor(rightMotorSpeed, leftMotorSpeed);
}

// Movement functions
void driveForward(int speed) {
  controlMotor(speed, speed);
}

void driveBackward(int speed) {
  controlMotor(-speed, -speed);
}

void turnLeft(int speed) {
  controlMotor(speed, speed / 2);
}

void turnRight(int speed) {
  controlMotor(speed / 2, speed);
}

void stopRobot() {
  controlMotor(0, 0);
}

void loop() {
  if (Serial.available() > 0) {
    char command = Serial.read();
    
    int v1 = digitalRead(D_1);
    int v2 = digitalRead(D_2);
    
    switch (command) {
      case 'f':
        currentMode = FOLLOW_ME;
        Serial.println("FOLLOW ME MODE ACTIVE");
        break;
        
      case 'g':
        currentMode = WALL_FOLLOW;
        Serial.println("WALL FOLLOW MODE ACTIVE (simple - no corners)");
        break;
        
      case 'c':
        currentMode = WALL_FOLLOW_CORNERS;
        cornerState = FOLLOWING;
        Serial.println("WALL FOLLOW WITH CORNERS MODE ACTIVE");
        break;
        
      case 't':  // Test sensors
        {
          float front = getDistance(TRIG_PIN_FRONT, ECHO_PIN_FRONT);
          float side = getDistance(TRIG_PIN_SIDE, ECHO_PIN_SIDE);
          Serial.print("Front: ");
          Serial.print(front);
          Serial.print(" cm | Side: ");
          Serial.print(side);
          Serial.println(" cm");
        }
        break;
        
      case 'w':
        currentMode = MANUAL;
        driveForward(65);
        Serial.print("FORWARD | Sensors: ");
        Serial.print(v1); 
        Serial.print(',');
        Serial.println(v2);
        break;
        
      case 's':
        currentMode = MANUAL;
        driveBackward(65);
        Serial.print("BACK | Sensors: ");
        Serial.print(v1); 
        Serial.print(',');
        Serial.println(v2);
        break;
        
      case 'a':
        currentMode = MANUAL;
        turnLeft(50);
        Serial.print("LEFT | Sensors: ");
        Serial.print(v1); 
        Serial.print(',');
        Serial.println(v2);
        break;
        
      case 'd':
        currentMode = MANUAL;
        turnRight(50);
        Serial.print("RIGHT | Sensors: ");
        Serial.print(v1); 
        Serial.print(',');
        Serial.println(v2);
        break;
        
      case 'x':
        currentMode = MANUAL;
        stopRobot();
        Serial.print("STOP | Sensors: ");
        Serial.print(v1); 
        Serial.print(',');
        Serial.println(v2);
        break;
        
      default:
        Serial.println("Commands: f=follow, g=wall, c=wall+corners, t=test, w/s/a/d/x=manual");
        break;
    }
  }
  
  if (currentMode == FOLLOW_ME) {
    followMe();
    delay(50);
  } else if (currentMode == WALL_FOLLOW) {
    followWall();
    delay(50);
  } else if (currentMode == WALL_FOLLOW_CORNERS) {
    followWallWithCorners();
    delay(50);
  } else {
    delay(10);
  }
}
