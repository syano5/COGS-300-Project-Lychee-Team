#define enA 9  // Enable pin for Motor A (right motor), PWM compatible
#define in1 8  // Direction control pin 1 for Motor A
#define in2 7  // Direction control pin 2 for Motor A 
#define enB 6  // Enable pin for Motor B (left motor), PWM compatible
#define in3 5  // Direction control pin 1 for Motor B
#define in4 4  // Direction control pin 2 for Motor B

// Front ultrasonic sensor pins (for Follow Me)
#define TRIG_PIN_FRONT 10
#define ECHO_PIN_FRONT 11

// Side ultrasonic sensor pins (for Wall Following) - on RIGHT side
#define TRIG_PIN_SIDE 12
#define ECHO_PIN_SIDE 13

const int D_1 = 2, D_2 = 3;

// P-controller parameters for Follow Me mode
const float SET_POINT_FOLLOW = 25.0;  // Target distance in cm for follow me
const float Kp_FOLLOW = 8.0;          // Proportional gain for follow me

// P-controller parameters for Wall Following mode
const float SET_POINT_WALL = 20.0;    // Target distance from wall in cm
const float Kp_WALL = 6.0;            // Proportional gain for wall following
const int WALL_FORWARD_SPEED = 80;    // Base forward speed when following wall

const int MAX_SPEED = 200;
const int MIN_SPEED = 50;

// Operating modes
enum Mode {
  MANUAL,
  FOLLOW_ME,
  WALL_FOLLOW
};

Mode currentMode = MANUAL;

// Note:
// in1 HIGH and in2 LOW --> FORWARDS
// in1 LOW and in2 HIGH --> BACKWARDS

void setup() {
  // Set motor control pins as outputs
  pinMode(enA, OUTPUT);
  pinMode(in1, OUTPUT);
  pinMode(in2, OUTPUT);
  pinMode(enB, OUTPUT);
  pinMode(in3, OUTPUT);
  pinMode(in4, OUTPUT);
  
  // Set ultrasonic sensor pins
  pinMode(TRIG_PIN_FRONT, OUTPUT);
  pinMode(ECHO_PIN_FRONT, INPUT);
  pinMode(TRIG_PIN_SIDE, OUTPUT);
  pinMode(ECHO_PIN_SIDE, INPUT);
  
  pinMode(D_1, INPUT_PULLUP);
  pinMode(D_2, INPUT_PULLUP);
  
  // Initialize serial communication
  Serial.begin(9600);
  Serial.println("Robot ready!");
  Serial.println("Commands:");
  Serial.println("  w/s/a/d/x = Manual control");
  Serial.println("  f = Follow Me mode");
  Serial.println("  g = Wall Follow mode (right wall)");
}

// Measure distance using specified ultrasonic sensor
float getDistance(int trigPin, int echoPin) {
  // Send 10us pulse to trigger
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  
  // Read echo pulse duration
  long duration = pulseIn(echoPin, HIGH, 30000);  // Timeout after 30ms
  
  // Calculate distance in cm
  if (duration == 0) {
    return -1;  // No echo received
  }
  
  float distance = duration * 0.034 / 2.0;
  return distance;
}

// Low-level motor control function
void controlMotor(int motorA_speed, int motorB_speed) {
  // Motor A (right motor) control
  if (motorA_speed >= 0) {
    digitalWrite(in1, HIGH);
    digitalWrite(in2, LOW);
  } else {
    digitalWrite(in1, LOW);
    digitalWrite(in2, HIGH);
    motorA_speed = -motorA_speed;
  }
  analogWrite(enA, constrain(motorA_speed, 0, 255));
  
  // Motor B (left motor) control
  if (motorB_speed >= 0) {
    digitalWrite(in3, HIGH);
    digitalWrite(in4, LOW);
  } else {
    digitalWrite(in3, LOW);
    digitalWrite(in4, HIGH);
    motorB_speed = -motorB_speed;
  }
  analogWrite(enB, constrain(motorB_speed, 0, 255));
}

// P-controller for follow-me behavior (front sensor)
void followMe() {
  float distance = getDistance(TRIG_PIN_FRONT, ECHO_PIN_FRONT);
  
  // Check for valid reading
  if (distance < 0 || distance > 100) {
    stopRobot();
    Serial.print("No object detected (distance: ");
    Serial.print(distance);
    Serial.println(" cm)");
    return;
  }
  
  // Calculate error (positive = too far, negative = too close)
  float error = distance - SET_POINT_FOLLOW;
  
  // Calculate output using P-controller
  float output = Kp_FOLLOW * error;
  
  // Map output to motor speed range
  int motorSpeed = constrain((int)output, -MAX_SPEED, MAX_SPEED);
  
  // Apply minimum speed threshold
  if (motorSpeed > 0 && motorSpeed < MIN_SPEED) {
    motorSpeed = MIN_SPEED;
  } else if (motorSpeed < 0 && motorSpeed > -MIN_SPEED) {
    motorSpeed = -MIN_SPEED;
  }
  
  // Create a deadband around the setpoint (Â±2cm)
  if (abs(error) < 2.0) {
    stopRobot();
    Serial.print("At target: ");
    Serial.print(distance);
    Serial.println(" cm");
  } else {
    controlMotor(motorSpeed, motorSpeed);
    
    Serial.print("Distance: ");
    Serial.print(distance);
    Serial.print(" cm, Error: ");
    Serial.print(error);
    Serial.print(" cm, Speed: ");
    Serial.println(motorSpeed);
  }
}

// P-controller for wall following (side sensor on RIGHT)
void followWall() {
  float wallDistance = getDistance(TRIG_PIN_SIDE, ECHO_PIN_SIDE);
  
  // Check for valid reading
  if (wallDistance < 0 || wallDistance > 100) {
    stopRobot();
    Serial.println("Wall lost - no reading from side sensor");
    return;
  }
  
  // Calculate error (positive = too far from wall, negative = too close to wall)
  float error = wallDistance - SET_POINT_WALL;
  
  // Calculate steering correction using P-controller
  float steeringCorrection = Kp_WALL * error;
  
  // Base speeds for both motors (moving forward)
  int rightMotorSpeed = WALL_FORWARD_SPEED;
  int leftMotorSpeed = WALL_FORWARD_SPEED;
  
  // Apply steering correction
  // If too far from wall (positive error): turn right (slow down right motor, speed up left)
  // If too close to wall (negative error): turn left (speed up right motor, slow down left)
  rightMotorSpeed -= steeringCorrection;
  leftMotorSpeed += steeringCorrection;
  
  // Constrain speeds
  rightMotorSpeed = constrain(rightMotorSpeed, 30, 150);
  leftMotorSpeed = constrain(leftMotorSpeed, 30, 150);
  
  // Drive with differential steering
  controlMotor(rightMotorSpeed, leftMotorSpeed);
  
  Serial.print("Wall distance: ");
  Serial.print(wallDistance);
  Serial.print(" cm, Error: ");
  Serial.print(error);
  Serial.print(" cm, Motors R:");
  Serial.print(rightMotorSpeed);
  Serial.print(" L:");
  Serial.println(leftMotorSpeed);
}

// Drive the robot forwards
void driveForward(int speed) {
  controlMotor(speed, speed);
}

// Drive the robot backwards
void driveBackward(int speed) {
  controlMotor(-speed, -speed);
}

// Turn the robot left while driving forward
void turnLeft(int speed) {
  controlMotor(speed, speed / 2);
}

// Turn the robot right while driving forward
void turnRight(int speed) {
  controlMotor(speed / 2, speed);
}

// Stop the robot
void stopRobot() {
  controlMotor(0, 0);
}

void loop() {
  // Check if data is available from Serial Monitor
  if (Serial.available() > 0) {
    char command = Serial.read();
    
    // Read sensor values
    int v1 = digitalRead(D_1);
    int v2 = digitalRead(D_2);
    
    switch (command) {
      case 'f':  // Enter Follow Me mode
        currentMode = FOLLOW_ME;
        Serial.println("FOLLOW ME MODE ACTIVE");
        break;
        
      case 'g':  // Enter Wall Follow mode
        currentMode = WALL_FOLLOW;
        Serial.println("WALL FOLLOW MODE ACTIVE (following right wall)");
        break;
        
      case 't':  // Test side sensor
        {
          float dist = getDistance(TRIG_PIN_SIDE, ECHO_PIN_SIDE);
          Serial.print("Side sensor test: ");
          Serial.print(dist);
          Serial.println(" cm");
        }
        break;
        
      case 'w':  // Forward
        currentMode = MANUAL;
        driveForward(65);
        Serial.print("FORWARD | Sensors: ");
        Serial.print(v1); 
        Serial.print(',');
        Serial.println(v2);
        break;
        
      case 's':  // Backward
        currentMode = MANUAL;
        driveBackward(65);
        Serial.print("BACK | Sensors: ");
        Serial.print(v1); 
        Serial.print(',');
        Serial.println(v2);
        break;
        
      case 'a':  // Left
        currentMode = MANUAL;
        turnLeft(50);
        Serial.print("LEFT | Sensors: ");
        Serial.print(v1); 
        Serial.print(',');
        Serial.println(v2);
        break;
        
      case 'd':  // Right
        currentMode = MANUAL;
        turnRight(50);
        Serial.print("RIGHT | Sensors: ");
        Serial.print(v1); 
        Serial.print(',');
        Serial.println(v2);
        break;
        
      case 'x':  // Stop
        currentMode = MANUAL;
        stopRobot();
        Serial.print("STOP | Sensors: ");
        Serial.print(v1); 
        Serial.print(',');
        Serial.println(v2);
        break;
        
      default:
        Serial.println("Commands: f=follow me, g=wall follow, w/s/a/d/x=manual");
        break;
    }
  }
  
  // Execute current mode
  if (currentMode == FOLLOW_ME) {
    followMe();
    delay(50);
  } else if (currentMode == WALL_FOLLOW) {
    followWall();
    delay(50);
  } else {
    delay(10);
  }
}
