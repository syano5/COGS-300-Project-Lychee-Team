// -------------------- Object Detection Sensor Pins --------------------
#define OBJECT_SENSOR_LEFT A0    // Left object sensor (analog)
#define OBJECT_SENSOR_RIGHT A1   // Right object sensor (analog) 
#define OBJECT_SENSOR_FRONT A2   // Front object sensor (analog)

// -------------------- Arena Boundary Sensors --------------------
#define TAPE_SENSOR_LEFT 0       // Left tape detection
#define TAPE_SENSOR_RIGHT 1      // Right tape detection
#define TAPE_SENSOR_FRONT 2      // Front tape detection

// -------------------- Motor Pins --------------------
#define enA 9      // Left motor speed control
#define in1 8      // Left motor direction 1
#define in2 7      // Left motor direction 2
#define enB 6      // Right motor speed control  
#define in3 5      // Right motor direction 1
#define in4 4      // Right motor direction 2

// -------------------- Variables --------------------
int baseSpeed = 100;
int searchSpeed = 80;
int turnSpeed = 70;

// Object tracking states
enum TrackingState {
  SEARCHING,           // Looking for object
  TRACKING,            // Following object
  APPROACHING,         // Close to object
  TOUCHING,            // Making contact
  AVOIDING_TAPE,       // Backing from boundary
  RECOVERY             // Lost object recovery
};

TrackingState currentState = SEARCHING;

// Object detection thresholds
int objectThreshold = 500;       // Analog reading threshold for object detection
int closeObjectThreshold = 700;  // Very close to object
int tapeThreshold = 200;         // Digital threshold for tape detection

// Search behavior
unsigned long lastObjectSeen = 0;
int searchDirection = 1;         // 1 = right, -1 = left
int searchPattern = 0;           // 0 = spiral, 1 = zigzag
int recoveryAttempts = 0;

// NEW: Add missing variable declarations
int lastDirection = 0;           // -1 left, 0 straight, 1 right (for tracking)
int lastObjectPosition = 0;      // -1 left, 0 center, 1 right

void setup() {
  Serial.begin(115200);
  
  // Motor pins setup
  pinMode(enA, OUTPUT);
  pinMode(in1, OUTPUT);
  pinMode(in2, OUTPUT);
  pinMode(enB, OUTPUT);
  pinMode(in3, OUTPUT);
  pinMode(in4, OUTPUT);
  
  // Sensor setup
  pinMode(OBJECT_SENSOR_LEFT, INPUT);
  pinMode(OBJECT_SENSOR_RIGHT, INPUT);
  pinMode(OBJECT_SENSOR_FRONT, INPUT);
  pinMode(TAPE_SENSOR_LEFT, INPUT);
  pinMode(TAPE_SENSOR_RIGHT, INPUT);
  pinMode(TAPE_SENSOR_FRONT, INPUT);
  
  stopMotors();
  Serial.println("Object Tracking Robot Ready!");
  delay(2000);
}

void loop() {
  // Read all sensors
  int objectLeft = analogRead(OBJECT_SENSOR_LEFT);
  int objectRight = analogRead(OBJECT_SENSOR_RIGHT);
  int objectFront = analogRead(OBJECT_SENSOR_FRONT);
  
  bool tapeLeft = digitalRead(TAPE_SENSOR_LEFT) < tapeThreshold;
  bool tapeRight = digitalRead(TAPE_SENSOR_RIGHT) < tapeThreshold;
  bool tapeFront = digitalRead(TAPE_SENSOR_FRONT) < tapeThreshold;
  
  // Debug output
  Serial.print("State:");
  Serial.print(currentState);
  Serial.print(" L:");
  Serial.print(objectLeft);
  Serial.print(" R:");
  Serial.print(objectRight);
  Serial.print(" F:");
  Serial.print(objectFront);
  Serial.print(" Tape L:");
  Serial.print(tapeLeft);
  Serial.print(" R:");
  Serial.print(tapeRight);
  Serial.print(" F:");
  Serial.println(tapeFront);

  // State machine for object tracking
  switch(currentState) {
    
    case SEARCHING:
      handleSearching(objectLeft, objectRight, objectFront, tapeLeft, tapeRight, tapeFront);
      break;
      
    case TRACKING:
      handleTracking(objectLeft, objectRight, objectFront, tapeLeft, tapeRight, tapeFront);
      break;
      
    case APPROACHING:
      handleApproaching(objectLeft, objectRight, objectFront, tapeLeft, tapeRight, tapeFront);
      break;
      
    case AVOIDING_TAPE:
      handleAvoidingTape(tapeLeft, tapeRight, tapeFront, objectLeft, objectRight, objectFront);
      break;
      
    case RECOVERY:
      handleRecovery(objectLeft, objectRight, objectFront, tapeLeft, tapeRight, tapeFront);
      break;
      
    case TOUCHING:
      handleTouching();
      break;
  }
  
  delay(50);
}

// -------------------- STATE HANDLERS --------------------

void handleSearching(int objLeft, int objRight, int objFront, bool tapeL, bool tapeR, bool tapeF) {
  // Check for tape first
  if (tapeL || tapeR || tapeF) {
    currentState = AVOIDING_TAPE;
    return;
  }
  
  // Check if object found
  if (objLeft > objectThreshold || objRight > objectThreshold || objFront > objectThreshold) {
    currentState = TRACKING;
    lastObjectSeen = millis();
    recoveryAttempts = 0;
    Serial.println("Object found! Switching to TRACKING");
    return;
  }
  
  // Implement search patterns
  if (searchPattern == 0) {
    // Spiral search pattern
    spiralSearch();
  } else {
    // Zigzag search pattern  
    zigzagSearch();
  }
}

void handleTracking(int objLeft, int objRight, int objFront, bool tapeL, bool tapeR, bool tapeF) {
  // Emergency tape avoidance
  if (tapeL || tapeR || tapeF) {
    currentState = AVOIDING_TAPE;
    return;
  }
  
  // Check if object is very close
  if (objFront > closeObjectThreshold) {
    currentState = APPROACHING;
    Serial.println("Object close! Switching to APPROACHING");
    return;
  }
  
  // Check if object lost
  if (objLeft < objectThreshold && objRight < objectThreshold && objFront < objectThreshold) {
    if (millis() - lastObjectSeen > 2000) { // Lost for 2 seconds
      currentState = RECOVERY;
      Serial.println("Object lost! Switching to RECOVERY");
    } else {
      // Temporary loss - continue in last direction
      if (lastDirection == -1) {
        gentleLeft();
      } else if (lastDirection == 1) {
        gentleRight();
      } else {
        driveForward();
      }
      Serial.println("Tracking: Temporary loss - continuing last direction");
    }
    return;
  }
  
  // Object tracking logic
  lastObjectSeen = millis();
  
  // Determine object position and track
  if (objFront > objectThreshold && objLeft > objectThreshold && objRight > objectThreshold) {
    // Object centered and close - move forward
    driveForward();
    lastDirection = 0;
    lastObjectPosition = 0;
    Serial.println("Tracking: Centered - Forward");
  }
  else if (objLeft > objRight && objLeft > objectThreshold) {
    // Object more on left - turn left
    gentleLeft();
    lastDirection = -1;
    lastObjectPosition = -1;
    Serial.println("Tracking: Object left - Gentle left");
  }
  else if (objRight > objLeft && objRight > objectThreshold) {
    // Object more on right - turn right  
    gentleRight();
    lastDirection = 1;
    lastObjectPosition = 1;
    Serial.println("Tracking: Object right - Gentle right");
  }
  else if (objFront > objectThreshold) {
    // Only front sensor sees object
    driveForward();
    lastDirection = 0;
    lastObjectPosition = 0;
    Serial.println("Tracking: Front only - Forward");
  }
}

void handleApproaching(int objLeft, int objRight, int objFront, bool tapeL, bool tapeR, bool tapeF) {
  // Slow approach for final touch
  if (objFront > closeObjectThreshold + 100) { // Very close threshold
    currentState = TOUCHING;
    Serial.println("TOUCHING OBJECT! SUCCESS!");
    stopMotors();
    return;
  }
  
  if (tapeL || tapeR || tapeF) {
    currentState = AVOIDING_TAPE;
    return;
  }
  
  // Slow forward movement
  slowForward();
  lastDirection = 0;
  Serial.println("Approaching: Slow forward");
}

void handleAvoidingTape(bool tapeL, bool tapeR, bool tapeF, int objLeft, int objRight, int objFront) {
  Serial.println("Avoiding tape boundary!");
  
  // Back up first
  driveBackward();
  delay(500);
  stopMotors();
  
  // Turn away from tape
  if (tapeL) {
    // Tape on left, turn right
    sharpRight();
    lastDirection = 1;
    Serial.println("Tape left - Turning right");
  } 
  else if (tapeR) {
    // Tape on right, turn left
    sharpLeft();
    lastDirection = -1;
    Serial.println("Tape right - Turning left");
  }
  else if (tapeF) {
    // Tape in front, turn 180 degrees
    if (random(2) == 0) {
      sharpLeft();
      lastDirection = -1;
    } else {
      sharpRight();
      lastDirection = 1;
    }
    Serial.println("Tape front - Turning around");
  }
  
  delay(800); // Turn for 800ms
  stopMotors();
  
  // Return to searching
  currentState = SEARCHING;
  recoveryAttempts++;
  
  // Change search pattern if hitting tape frequently
  if (recoveryAttempts > 3) {
    searchPattern = 1 - searchPattern; // Switch pattern
    recoveryAttempts = 0;
    Serial.println("Changing search pattern due to frequent tape hits");
  }
}

void handleRecovery(int objLeft, int objRight, int objFront, bool tapeL, bool tapeR, bool tapeF) {
  Serial.println("Recovery: Attempting to reacquire object");
  
  // Check if object found during recovery
  if (objLeft > objectThreshold || objRight > objectThreshold || objFront > objectThreshold) {
    currentState = TRACKING;
    lastObjectSeen = millis();
    Serial.println("Object reacquired! Back to TRACKING");
    return;
  }
  
  // Systematic recovery search
  recoverySearch();
  
  // If recovery takes too long, go back to general search
  if (millis() - lastObjectSeen > 5000) {
    currentState = SEARCHING;
    Serial.println("Recovery failed, returning to SEARCHING");
  }
}

void handleTouching() {
  // Success state - object touched
  // Flash lights, play sound, or just stop
  Serial.println("*** OBJECT TOUCHED - MISSION COMPLETE ***");
  
  // Optional: celebrate and stop
  stopMotors();
  // Add celebration routine here if desired
}

// -------------------- SEARCH PATTERNS --------------------

void spiralSearch() {
  // Spiral outward search pattern
  static unsigned long lastDirectionChange = 0;
  static int spiralSize = 0;
  
  if (millis() - lastDirectionChange > 2000) {
    spiralSize++;
    searchDirection = -searchDirection; // Change direction
    lastDirectionChange = millis();
  }
  
  // Gentle curve in current direction
  if (searchDirection == 1) {
    gentleRight();
    lastDirection = 1;
  } else {
    gentleLeft();
    lastDirection = -1;
  }
}

void zigzagSearch() {
  // Zigzag search pattern
  static unsigned long lastZigzag = 0;
  static bool zigRight = true;
  
  if (millis() - lastZigzag > 1500) {
    zigRight = !zigRight;
    lastZigzag = millis();
  }
  
  if (zigRight) {
    gentleRight();
    lastDirection = 1;
  } else {
    gentleLeft();
    lastDirection = -1;
  }
}

void recoverySearch() {
  // Methodical search around last known position
  static unsigned long lastRecoveryAction = 0;
  static int recoveryStep = 0;
  
  if (millis() - lastRecoveryAction > 1000) {
    recoveryStep = (recoveryStep + 1) % 4;
    lastRecoveryAction = millis();
  }
  
  switch(recoveryStep) {
    case 0: 
      driveForward(); 
      lastDirection = 0;
      break;
    case 1: 
      sharpLeft(); 
      lastDirection = -1;
      break;
    case 2: 
      driveForward(); 
      lastDirection = 0;
      break;
    case 3: 
      sharpRight(); 
      lastDirection = 1;
      break;
  }
}

// -------------------- MOTOR CONTROL FUNCTIONS --------------------

void driveForward() {
  digitalWrite(in1, HIGH);
  digitalWrite(in2, LOW);
  analogWrite(enA, baseSpeed);
  digitalWrite(in3, HIGH);
  digitalWrite(in4, LOW);
  analogWrite(enB, baseSpeed);
}

void slowForward() {
  digitalWrite(in1, HIGH);
  digitalWrite(in2, LOW);
  analogWrite(enA, baseSpeed/2);
  digitalWrite(in3, HIGH);
  digitalWrite(in4, LOW);
  analogWrite(enB, baseSpeed/2);
}

void driveBackward() {
  digitalWrite(in1, LOW);
  digitalWrite(in2, HIGH);
  analogWrite(enA, baseSpeed/2);
  digitalWrite(in3, LOW);
  digitalWrite(in4, HIGH);
  analogWrite(enB, baseSpeed/2);
}

void gentleLeft() {
  digitalWrite(in1, HIGH);
  digitalWrite(in2, LOW);
  analogWrite(enA, baseSpeed - 20);
  digitalWrite(in3, HIGH);
  digitalWrite(in4, LOW);
  analogWrite(enB, baseSpeed);
}

void gentleRight() {
  digitalWrite(in1, HIGH);
  digitalWrite(in2, LOW);
  analogWrite(enA, baseSpeed);
  digitalWrite(in3, HIGH);
  digitalWrite(in4, LOW);
  analogWrite(enB, baseSpeed - 20);
}

void sharpLeft() {
  digitalWrite(in1, HIGH);
  digitalWrite(in2, LOW);
  analogWrite(enA, turnSpeed);
  digitalWrite(in3, HIGH);
  digitalWrite(in4, LOW);
  analogWrite(enB, baseSpeed);
}

void sharpRight() {
  digitalWrite(in1, HIGH);
  digitalWrite(in2, LOW);
  analogWrite(enA, baseSpeed);
  digitalWrite(in3, HIGH);
  digitalWrite(in4, LOW);
  analogWrite(enB, turnSpeed);
}

void stopMotors() {
  digitalWrite(in1, LOW);
  digitalWrite(in2, LOW);
  analogWrite(enA, 0);
  digitalWrite(in3, LOW);
  digitalWrite(in4, LOW);
  analogWrite(enB, 0);
}
