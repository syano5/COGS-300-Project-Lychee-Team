#include <Servo.h>

// -------------------- Servo Setup --------------------
#define SERVO_PIN 3
Servo scanServo;
int servoPos = 90;
int servoIncrement = 5;
int sweepDelay = 15;

// -------------------- Ultrasonic Pins --------------------
#define TRIG_PIN 10
#define ECHO_PIN 11

// -------------------- Object Detection Sensor Pins --------------------
#define OBJECT_SENSOR_LEFT A0    // Left object sensor (analog)
#define OBJECT_SENSOR_RIGHT A1   // Right object sensor (analog) 
#define OBJECT_SENSOR_FRONT A2   // Front object sensor (analog)

// -------------------- Arena Boundary Sensors --------------------
#define TAPE_SENSOR_LEFT 0       // Left tape detection
#define TAPE_SENSOR_RIGHT 1      // Right tape detection
#define TAPE_SENSOR_FRONT 2      // Front tape detection

// -------------------- Motor Pins --------------------
#define enA 9      // Left motor speed control
#define in1 8      // Left motor direction 1
#define in2 7      // Left motor direction 2
#define enB 6      // Right motor speed control  
#define in3 5      // Right motor direction 1
#define in4 4      // Right motor direction 2

// -------------------- Constants --------------------
const float ULTRASONIC_DETECTION_RANGE = 150.0; // cm (~5 ft)
const float ULTRASONIC_CLOSE_RANGE = 40.0;      // cm for close approach
const float ULTRASONIC_STOP_DISTANCE = 25.0;    // cm (~10 inches)

// -------------------- Variables --------------------
int baseSpeed = 100;
int searchSpeed = 80;
int turnSpeed = 70;

// Object tracking states
enum TrackingState {
  SEARCHING,           // Looking for object with servo sweep
  ORIENTING,           // Turning to face detected object
  TRACKING,            // Following object (IR sensors)
  APPROACHING,         // Close to object (ultrasonic guidance)
  TOUCHING,            // Making contact
  AVOIDING_TAPE,       // Backing from boundary
  RECOVERY             // Lost object recovery
};

TrackingState currentState = SEARCHING;

// Object detection thresholds
int objectThreshold = 500;       // Analog reading threshold for IR object detection
int closeObjectThreshold = 700;  // Very close to object (IR)
int tapeThreshold = 200;         // Digital threshold for tape detection

// Search behavior
unsigned long lastObjectSeen = 0;
int searchDirection = 1;         // 1 = right, -1 = left
int searchPattern = 0;           // 0 = spiral, 1 = zigzag
int recoveryAttempts = 0;

// Servo scanning variables
bool objectFoundByUltrasonic = false;
int detectedObjectAngle = 90;
float detectedObjectDistance = 0;

// Tracking variables
int lastDirection = 0;           // -1 left, 0 straight, 1 right
int lastObjectPosition = 0;      // -1 left, 0 center, 1 right

// -------------------- Setup --------------------
void setup() {
  Serial.begin(115200);
  
  // Servo setup
  scanServo.attach(SERVO_PIN, 500, 2500);
  scanServo.write(90);
  
  // Motor pins setup
  pinMode(enA, OUTPUT);
  pinMode(in1, OUTPUT);
  pinMode(in2, OUTPUT);
  pinMode(enB, OUTPUT);
  pinMode(in3, OUTPUT);
  pinMode(in4, OUTPUT);
  
  // Ultrasonic setup
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  
  // Sensor setup
  pinMode(OBJECT_SENSOR_LEFT, INPUT);
  pinMode(OBJECT_SENSOR_RIGHT, INPUT);
  pinMode(OBJECT_SENSOR_FRONT, INPUT);
  pinMode(TAPE_SENSOR_LEFT, INPUT);
  pinMode(TAPE_SENSOR_RIGHT, INPUT);
  pinMode(TAPE_SENSOR_FRONT, INPUT);
  
  stopMotors();
  Serial.println("Servo-Enhanced Object Tracking Robot Ready!");
  delay(2000);
}

// -------------------- Ultrasonic Distance Measurement --------------------
float getUltrasonicDistance() {
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);
  
  long duration = pulseIn(ECHO_PIN, HIGH, 30000); // timeout after 30ms
  if (duration == 0) return -1;
  return duration * 0.034 / 2.0;
}

// -------------------- Main Loop --------------------
void loop() {
  // Read all sensors
  int objectLeft = analogRead(OBJECT_SENSOR_LEFT);
  int objectRight = analogRead(OBJECT_SENSOR_RIGHT);
  int objectFront = analogRead(OBJECT_SENSOR_FRONT);
  
  bool tapeLeft = digitalRead(TAPE_SENSOR_LEFT) < tapeThreshold;
  bool tapeRight = digitalRead(TAPE_SENSOR_RIGHT) < tapeThreshold;
  bool tapeFront = digitalRead(TAPE_SENSOR_FRONT) < tapeThreshold;
  
  float ultrasonicDist = getUltrasonicDistance();
  
  // Debug output
  Serial.print("State:");
  Serial.print(currentState);
  Serial.print(" Servo:");
  Serial.print(servoPos);
  Serial.print("° US:");
  Serial.print(ultrasonicDist);
  Serial.print("cm L:");
  Serial.print(objectLeft);
  Serial.print(" R:");
  Serial.print(objectRight);
  Serial.print(" F:");
  Serial.print(objectFront);
  Serial.print(" Tape L:");
  Serial.print(tapeLeft);
  Serial.print(" R:");
  Serial.print(tapeRight);
  Serial.print(" F:");
  Serial.println(tapeFront);

  // State machine for object tracking
  switch(currentState) {
    
    case SEARCHING:
      handleSearching(objectLeft, objectRight, objectFront, tapeLeft, tapeRight, tapeFront, ultrasonicDist);
      break;
      
    case ORIENTING:
      handleOrienting();
      break;
      
    case TRACKING:
      handleTracking(objectLeft, objectRight, objectFront, tapeLeft, tapeRight, tapeFront, ultrasonicDist);
      break;
      
    case APPROACHING:
      handleApproaching(objectLeft, objectRight, objectFront, tapeLeft, tapeRight, tapeFront, ultrasonicDist);
      break;
      
    case AVOIDING_TAPE:
      handleAvoidingTape(tapeLeft, tapeRight, tapeFront, objectLeft, objectRight, objectFront);
      break;
      
    case RECOVERY:
      handleRecovery(objectLeft, objectRight, objectFront, tapeLeft, tapeRight, tapeFront, ultrasonicDist);
      break;
      
    case TOUCHING:
      handleTouching();
      break;
  }
  
  delay(50);
}

// -------------------- STATE HANDLERS --------------------

void handleSearching(int objLeft, int objRight, int objFront, bool tapeL, bool tapeR, bool tapeF, float usDist) {
  // Check for tape first
  if (tapeL || tapeR || tapeF) {
    currentState = AVOIDING_TAPE;
    return;
  }
  
  // Check IR sensors for nearby objects
  if (objLeft > objectThreshold || objRight > objectThreshold || objFront > objectThreshold) {
    currentState = TRACKING;
    lastObjectSeen = millis();
    recoveryAttempts = 0;
    scanServo.write(90); // Center servo for tracking
    Serial.println("Object found by IR! Switching to TRACKING");
    return;
  }
  
  // Perform servo sweep with ultrasonic
  servoSweepAndDetect(usDist);
  
  // If object found by ultrasonic, orient toward it
  if (objectFoundByUltrasonic) {
    currentState = ORIENTING;
    Serial.println("Object found by ultrasonic! Switching to ORIENTING");
    return;
  }
  
  // Otherwise continue search pattern
  if (searchPattern == 0) {
    spiralSearch();
  } else {
    zigzagSearch();
  }
}

void servoSweepAndDetect(float distance) {
  static int direction = 1;
  
  scanServo.write(servoPos);
  
  if (distance > 0) {
    Serial.print("  Sweep angle ");
    Serial.print(servoPos);
    Serial.print("° | Distance: ");
    Serial.print(distance);
    Serial.println(" cm");
  }
  
  // Check if object detected within range
  if (distance > 0 && distance <= ULTRASONIC_DETECTION_RANGE) {
    Serial.print(">>> Ultrasonic detected object at ");
    Serial.print(distance);
    Serial.print(" cm | angle ");
    Serial.println(servoPos);
    objectFoundByUltrasonic = true;
    detectedObjectAngle = servoPos;
    detectedObjectDistance = distance;
    return;
  }
  
  // Continue sweeping
  servoPos += direction * servoIncrement;
  if (servoPos >= 180 || servoPos <= 0) {
    direction = -direction;
  }
}

void handleOrienting() {
  // Turn robot to face the detected object
  int turnAmount = detectedObjectAngle - 90;
  
  Serial.print("Orienting toward angle: ");
  Serial.print(detectedObjectAngle);
  Serial.print(" (turn amount: ");
  Serial.print(turnAmount);
  Serial.println("°)");
  
  if (abs(turnAmount) > 10) {
    if (turnAmount > 0) {
      // Turn right
      sharpRight();
      delay(abs(turnAmount) * 10); // Adjust timing as needed
    } else {
      // Turn left
      sharpLeft();
      delay(abs(turnAmount) * 10);
    }
  }
  
  stopMotors();
  scanServo.write(90); // Center ultrasonic forward
  delay(300);
  
  // Reset flag and transition to tracking
  objectFoundByUltrasonic = false;
  currentState = TRACKING;
  lastObjectSeen = millis();
  Serial.println("Orientation complete. Switching to TRACKING");
}

void handleTracking(int objLeft, int objRight, int objFront, bool tapeL, bool tapeR, bool tapeF, float usDist) {
  // Emergency tape avoidance
  if (tapeL || tapeR || tapeF) {
    currentState = AVOIDING_TAPE;
    return;
  }
  
  // Use ultrasonic for approaching if object is close
  if (usDist > 0 && usDist <= ULTRASONIC_CLOSE_RANGE) {
    currentState = APPROACHING;
    Serial.println("Object in ultrasonic close range! Switching to APPROACHING");
    return;
  }
  
  // Check if IR detects very close object
  if (objFront > closeObjectThreshold) {
    currentState = APPROACHING;
    Serial.println("IR detects close object! Switching to APPROACHING");
    return;
  }
  
  // Check if object lost
  if (objLeft < objectThreshold && objRight < objectThreshold && objFront < objectThreshold) {
    if (millis() - lastObjectSeen > 2000) { // Lost for 2 seconds
      currentState = RECOVERY;
      Serial.println("Object lost! Switching to RECOVERY");
    } else {
      // Temporary loss - continue in last direction
      if (lastDirection == -1) {
        gentleLeft();
      } else if (lastDirection == 1) {
        gentleRight();
      } else {
        driveForward();
      }
      Serial.println("Tracking: Temporary loss - continuing last direction");
    }
    return;
  }
  
  // Object tracking logic using IR sensors
  lastObjectSeen = millis();
  
  if (objFront > objectThreshold && objLeft > objectThreshold && objRight > objectThreshold) {
    // Object centered - move forward
    driveForward();
    lastDirection = 0;
    Serial.println("Tracking: Centered - Forward");
  }
  else if (objLeft > objRight && objLeft > objectThreshold) {
    // Object on left
    gentleLeft();
    lastDirection = -1;
    Serial.println("Tracking: Object left - Gentle left");
  }
  else if (objRight > objLeft && objRight > objectThreshold) {
    // Object on right
    gentleRight();
    lastDirection = 1;
    Serial.println("Tracking: Object right - Gentle right");
  }
  else if (objFront > objectThreshold) {
    // Only front sensor
    driveForward();
    lastDirection = 0;
    Serial.println("Tracking: Front only - Forward");
  }
}

void handleApproaching(int objLeft, int objRight, int objFront, bool tapeL, bool tapeR, bool tapeF, float usDist) {
  if (tapeL || tapeR || tapeF) {
    currentState = AVOIDING_TAPE;
    return;
  }
  
  // Use ultrasonic for precise distance control
  if (usDist > 0 && usDist <= ULTRASONIC_STOP_DISTANCE) {
    currentState = TOUCHING;
    Serial.print("TOUCHING OBJECT! Distance: ");
    Serial.print(usDist);
    Serial.println(" cm - SUCCESS!");
    stopMotors();
    return;
  }
  
  // Check if object lost
  if (usDist < 0 || usDist > ULTRASONIC_DETECTION_RANGE) {
    Serial.println("Lost object during approach! Returning to RECOVERY");
    currentState = RECOVERY;
    return;
  }
  
  // Proportional speed control based on distance
  float error = usDist - ULTRASONIC_STOP_DISTANCE;
  int approachSpeed = constrain(baseSpeed/2 + (int)(error * 2), 40, baseSpeed);
  
  // Use IR sensors for lateral correction
  if (objLeft > objRight && objLeft > objectThreshold) {
    // Drift left slightly
    controlMotor(approachSpeed - 10, approachSpeed);
  } else if (objRight > objLeft && objRight > objectThreshold) {
    // Drift right slightly
    controlMotor(approachSpeed, approachSpeed - 10);
  } else {
    // Go straight
    controlMotor(approachSpeed, approachSpeed);
  }
  
  Serial.print("Approaching: Distance: ");
  Serial.print(usDist);
  Serial.print(" cm | Speed: ");
  Serial.println(approachSpeed);
}

void handleAvoidingTape(bool tapeL, bool tapeR, bool tapeF, int objLeft, int objRight, int objFront) {
  Serial.println("Avoiding tape boundary!");
  
  // Back up first
  driveBackward();
  delay(500);
  stopMotors();
  
  // Turn away from tape
  if (tapeL) {
    sharpRight();
    lastDirection = 1;
    Serial.println("Tape left - Turning right");
  } 
  else if (tapeR) {
    sharpLeft();
    lastDirection = -1;
    Serial.println("Tape right - Turning left");
  }
  else if (tapeF) {
    if (random(2) == 0) {
      sharpLeft();
      lastDirection = -1;
    } else {
      sharpRight();
      lastDirection = 1;
    }
    Serial.println("Tape front - Turning around");
  }
  
  delay(800);
  stopMotors();
  
  // Return to searching
  currentState = SEARCHING;
  servoPos = 90; // Reset servo
  recoveryAttempts++;
  
  if (recoveryAttempts > 3) {
    searchPattern = 1 - searchPattern;
    recoveryAttempts = 0;
    Serial.println("Changing search pattern");
  }
}

void handleRecovery(int objLeft, int objRight, int objFront, bool tapeL, bool tapeR, bool tapeF, float usDist) {
  Serial.println("Recovery: Attempting to reacquire object");
  
  // Check IR sensors
  if (objLeft > objectThreshold || objRight > objectThreshold || objFront > objectThreshold) {
    currentState = TRACKING;
    lastObjectSeen = millis();
    Serial.println("Object reacquired by IR! Back to TRACKING");
    return;
  }
  
  // Check ultrasonic
  if (usDist > 0 && usDist <= ULTRASONIC_DETECTION_RANGE) {
    Serial.println("Object detected by ultrasonic during recovery!");
    objectFoundByUltrasonic = true;
    detectedObjectAngle = servoPos;
    detectedObjectDistance = usDist;
    currentState = ORIENTING;
    return;
  }
  
  // Perform servo sweep during recovery
  servoSweepAndDetect(usDist);
  
  // Systematic recovery search
  recoverySearch();
  
  // Timeout back to searching
  if (millis() - lastObjectSeen > 5000) {
    currentState = SEARCHING;
    servoPos = 90;
    Serial.println("Recovery timeout, returning to SEARCHING");
  }
}

void handleTouching() {
  Serial.println("*** OBJECT TOUCHED - MISSION COMPLETE ***");
  stopMotors();
  // Optional: Add celebration routine
}

// -------------------- SEARCH PATTERNS --------------------

void spiralSearch() {
  static unsigned long lastDirectionChange = 0;
  static int spiralSize = 0;
  
  if (millis() - lastDirectionChange > 2000) {
    spiralSize++;
    searchDirection = -searchDirection;
    lastDirectionChange = millis();
  }
  
  if (searchDirection == 1) {
    gentleRight();
    lastDirection = 1;
  } else {
    gentleLeft();
    lastDirection = -1;
  }
}

void zigzagSearch() {
  static unsigned long lastZigzag = 0;
  static bool zigRight = true;
  
  if (millis() - lastZigzag > 1500) {
    zigRight = !zigRight;
    lastZigzag = millis();
  }
  
  if (zigRight) {
    gentleRight();
    lastDirection = 1;
  } else {
    gentleLeft();
    lastDirection = -1;
  }
}

void recoverySearch() {
  static unsigned long lastRecoveryAction = 0;
  static int recoveryStep = 0;
  
  if (millis() - lastRecoveryAction > 1000) {
    recoveryStep = (recoveryStep + 1) % 4;
    lastRecoveryAction = millis();
  }
  
  switch(recoveryStep) {
    case 0: 
      driveForward(); 
      lastDirection = 0;
      break;
    case 1: 
      sharpLeft(); 
      lastDirection = -1;
      break;
    case 2: 
      driveForward(); 
      lastDirection = 0;
      break;
    case 3: 
      sharpRight(); 
      lastDirection = 1;
      break;
  }
}

// -------------------- MOTOR CONTROL FUNCTIONS --------------------

void controlMotor(int motorA_speed, int motorB_speed) {
  if (motorA_speed >= 0) {
    digitalWrite(in1, HIGH);
    digitalWrite(in2, LOW);
  } else {
    digitalWrite(in1, LOW);
    digitalWrite(in2, HIGH);
    motorA_speed = -motorA_speed;
  }
  analogWrite(enA, constrain(motorA_speed, 0, 255));

  if (motorB_speed >= 0) {
    digitalWrite(in3, HIGH);
    digitalWrite(in4, LOW);
  } else {
    digitalWrite(in3, LOW);
    digitalWrite(in4, HIGH);
    motorB_speed = -motorB_speed;
  }
  analogWrite(enB, constrain(motorB_speed, 0, 255));
}

void driveForward() {
  controlMotor(baseSpeed, baseSpeed);
}

void slowForward() {
  controlMotor(baseSpeed/2, baseSpeed/2);
}

void driveBackward() {
  controlMotor(-baseSpeed/2, -baseSpeed/2);
}

void gentleLeft() {
  controlMotor(baseSpeed - 20, baseSpeed);
}

void gentleRight() {
  controlMotor(baseSpeed, baseSpeed - 20);
}

void sharpLeft() {
  controlMotor(-turnSpeed, turnSpeed);
}

void sharpRight() {
  controlMotor(turnSpeed, -turnSpeed);
}

void stopMotors() {
  controlMotor(0, 0);
}
